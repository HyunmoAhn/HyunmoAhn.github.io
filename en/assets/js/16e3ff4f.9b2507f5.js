"use strict";(self.webpackChunkhyunmoahn_github_io=self.webpackChunkhyunmoahn_github_io||[]).push([[9213],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),c=s(n),u=i,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||o;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:i,r[1]=p;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2017:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return p},metadata:function(){return s},toc:function(){return m}});var a=n(3117),i=n(102),o=(n(7294),n(3905)),r=["components"],p={slug:"deep-dive-to-immer",title:"Deep dive to immer",description:"immer, usually used by redux, help us to update mutable object like using immutably. How can it do this? Lets deep dive to immer.",keywords:["redux","redux-toolkit","immer","immutable","javascript","deep-dive","how-to-work","web"],authors:"HyunmoAhn",tags:["redux","redux-toolkit","immer","library","how-to-work","deep-dive","javascript","web","immutable"]},l=void 0,s={permalink:"/en/deep-dive-to-immer",source:"@site/i18n/en/docusaurus-plugin-content-blog/2021-10-23-deep-dive-to-immer.md",title:"Deep dive to immer",description:"immer, usually used by redux, help us to update mutable object like using immutably. How can it do this? Lets deep dive to immer.",date:"2021-10-23T00:00:00.000Z",formattedDate:"October 23, 2021",tags:[{label:"redux",permalink:"/en/tags/redux"},{label:"redux-toolkit",permalink:"/en/tags/redux-toolkit"},{label:"immer",permalink:"/en/tags/immer"},{label:"library",permalink:"/en/tags/library"},{label:"how-to-work",permalink:"/en/tags/how-to-work"},{label:"deep-dive",permalink:"/en/tags/deep-dive"},{label:"javascript",permalink:"/en/tags/javascript"},{label:"web",permalink:"/en/tags/web"},{label:"immutable",permalink:"/en/tags/immutable"}],readingTime:26.85,hasTruncateMarker:!0,authors:[{name:"Hyunmo Ahn",title:"Front End Engineer @ Line Biz+",url:"https://github.com/HyunmoAhn",imageURL:"https://github.com/HyunmoAhn.png",key:"HyunmoAhn"}],frontMatter:{slug:"deep-dive-to-immer",title:"Deep dive to immer",description:"immer, usually used by redux, help us to update mutable object like using immutably. How can it do this? Lets deep dive to immer.",keywords:["redux","redux-toolkit","immer","immutable","javascript","deep-dive","how-to-work","web"],authors:"HyunmoAhn",tags:["redux","redux-toolkit","immer","library","how-to-work","deep-dive","javascript","web","immutable"]},prevItem:{title:"How to use OAS generator in Front-end environment?",permalink:"/en/how-to-use-oas-generator"},nextItem:{title:"how to time travel debugging at redux-devtools",permalink:"/en/how-to-time-travel-debugging-at-redux-devtools"}},d={authorsImageUrls:[void 0]},m=[{value:"What is my curious?",id:"what-is-my-curious",level:2},{value:"What is immer, and why?",id:"what-is-immer-and-why",level:2},{value:"Usage",id:"usage",level:2},{value:"About immer before deep-dive",id:"about-immer-before-deep-dive",level:2},{value:"immer doesn&#39;t update original data",id:"immer-doesnt-update-original-data",level:3},{value:"immer record if object is updated or not",id:"immer-record-if-object-is-updated-or-not",level:3},{value:"Recap",id:"recap",level:3},{value:"Deep dive to immer",id:"deep-dive-to-immer",level:2},{value:"scope",id:"scope",level:3},{value:"proxy",id:"proxy",level:3},{value:"new Proxy",id:"new-proxy",level:3},{value:"Traps of immer",id:"traps-of-immer",level:3},{value:"Get",id:"get",level:4},{value:"reuse of already created proxy (<code>value === peek(state.base_, prop)</code>)",id:"reuse-of-already-created-proxy-value--peekstatebase_-prop",level:5},{value:"Set",id:"set",level:4},{value:"Recap of Proxy",id:"recap-of-proxy",level:3},{value:"finalize",id:"finalize",level:2},{value:"using finalize with root proxy",id:"using-finalize-with-root-proxy",level:3},{value:"using finalize with return of recipe",id:"using-finalize-with-return-of-recipe",level:3},{value:"Recap",id:"recap-1",level:2},{value:"Answer the question",id:"answer-the-question",level:2},{value:"Reference",id:"reference",level:2}],c={toc:m};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This article basically takes time to learn about immer ",(0,o.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/"},"immer"),".\nIf you don't know immer, I recommend reading ",(0,o.kt)("a",{parentName:"p",href:"#what-is-immer-and-why"},"next chapter")," first."),(0,o.kt)("h2",{id:"what-is-my-curious"},"What is my curious?"),(0,o.kt)("admonition",{title:"Question",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Q1. How does ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," change the mutable update way to immutable update way?")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"immer")," functions to return data immutably even when using the object built-in method that changes to be mutable.\nLet's find out how this function works internally."),(0,o.kt)("p",null,"This example is following basic example of ",(0,o.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/#a-quick-example-for-comparison"},"immer official docs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import produce from \'immer\';\n\nconst baseState = [\n  { \n    title: "Learn TypeScript", \n    done: true,\n  },\n  { \n    title: "Try Immer", \n    done: false,\n  },\n]\n\nconst nextState = produce(baseState, (draft) => {\n  draft.push({ title: "Tweet about It" });\n  draft[1].done = true;\n})\n\nconsole.log(baseState === nextState) // false\nconsole.log(nextState)\n/*\n[\n  { \n    title: "Learn TypeScript", \n    done: true,\n  },\n  { \n    title: "Learn TypeScript", \n    done: true,\n  },\n  { \n    title: "Tweet about It",\n  },\n]\n*/\n')),(0,o.kt)("admonition",{title:"Question",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Q2. How does ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," use ",(0,o.kt)("inlineCode",{parentName:"p"},"structural sharing"),"?"),(0,o.kt)("p",{parentName:"admonition"},"*",(0,o.kt)("inlineCode",{parentName:"p"},"structural sharing"),": When coping an object, the same reference is used for an object that has not been changed.")),(0,o.kt)("p",null,"To update object immutably means that original object is copied to new object. In other word, copy needs to cost.\nWhen ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," copy object, the unchanged reference copies the object using the structural sharing method that is reused.\nLet's find out what kind of structural sharing is used in ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("admonition",{title:"Question",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Q3. ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," sometimes updates data through return rather than mutable updating the draft within ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function,\nin which case the logic is different?")),(0,o.kt)("p",null,"When using an ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),", there is a case of returning a new object instead of the mutable update method suggested above.\nThis is same as the method of returning objects from javascript immutably regardless of the immer.\n",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," ",(0,o.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/return"},"officially is guiding")," this way and\nThere will be many developers who use both methods, the method of changing objects to be mutable and method of changing objects to be immutable.\nLet's see what logic differences these differences cause in the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'// mutable method\nconst nextState = produce(baseState, (draft) => {\n  draft.push({ title: "Tweet about It" });\n  draft[1].done = true;\n})\n\n// highlight-start\n// immutable method\nconst nextState = produce(baseState, (draft) => {\n  return {\n    ...baseState,\n    { ...baseState[1], done: true },\n    { title: "Tweet about It" },\n  }\n})\n// highlight-end\n')),(0,o.kt)("admonition",{title:"PREREQUISITES",type:"info"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Experience using an ",(0,o.kt)("inlineCode",{parentName:"li"},"immer")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"redux-toolkit")),(0,o.kt)("li",{parentName:"ul"},"Understanding of ",(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"Proxy")," (optional)"))),(0,o.kt)("h2",{id:"what-is-immer-and-why"},"What is immer, and why?"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"If you know properly why we use ",(0,o.kt)("inlineCode",{parentName:"em"},"immer"),", this can be boring. If you know, Let's ",(0,o.kt)("a",{parentName:"em",href:"#usage"},"next chapter")))),(0,o.kt)("p",null,"What is ",(0,o.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/"},"immer"),"?\nLet's bring the introductory phrase from the official docs of ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("inlineCode",{parentName:"p"},"Immer")," (German for: always) is a tiny package that allows you to work with immutable state in a more convenient way.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"immer")," is the library that ensures that data is immutably updated in javascript."),(0,o.kt)("p",null,"Then, where is ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," being used? ",(0,o.kt)("br",null),"\nIn style guide of redux, ",(0,o.kt)("a",{parentName:"p",href:"https://ko.redux.js.org/style-guide/style-guide#use-redux-toolkit-for-writing-redux-logic"},"recommend to using redux-toolkit")," using redux\nand ",(0,o.kt)("a",{parentName:"p",href:"https://ko.redux.js.org/style-guide/style-guide#use-immer-for-writing-immutable-updates"},"recommend to using immer")," for managing object immutability.\nOf course, If you use ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/"},"redux-toolkit"),", you already are using immer because ",(0,o.kt)("inlineCode",{parentName:"p"},"redux-toolkit")," is using ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," internally"),(0,o.kt)("p",null,"It is recommended to refer to the ",(0,o.kt)("a",{parentName:"p",href:"https://ko.redux.js.org/style-guide/style-guide#use-immer-for-writing-immutable-updates"},"FAQ of redux")," for why immutable data should be used. ",(0,o.kt)("br",null),"\nTo briefly explain the content, it is as follows. ",(0,o.kt)("br",null),"\njavascript "),(0,o.kt)("p",null,"The variable except of primitive type like number, string etc. have mutable type in javascript.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Non-primitive")," types include objects and arrays.\nEven if a non-primitive type of variable is changed, the reference of the variable does not change.\nSo, If inner of object is changed, reference is not changed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"let primitive = 5;\nlet primitive2 = primitive;\n\nconsole.log(primitive === primitive2) // true\nprimitive2 = 10;\n\nconsole.log(primitive === primitive2) // false\n\n\nlet nonPrimitive = { a: 5 };\nlet nonPrimitive2 = nonPrimitive;\n\nconsole.log(nonPrimitive === nonPrimitive2) // true\n\nnonPrimitive2.b = 10;\n\nconsole.log(nonPrimitive === nonPrimitive2) // true\nconsole.log(nonPrimitive) \n// { a: 5, b: 10 }  \n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://redux-saga.js.org/"},"redux")," is using ",(0,o.kt)("inlineCode",{parentName:"p"},"shallow equality checking"),".\nWhen comparing whether the data is the same, ",(0,o.kt)("inlineCode",{parentName:"p"},"shallow equality checking")," doesn't check whether the inside of the data has changed,\nbut rather determines that the reference of the data has changed. If it is the same, it has not changed."),(0,o.kt)("p",null,"If using ",(0,o.kt)("inlineCode",{parentName:"p"},"deep eqaulity checking"),", we suffer performance losses because all object have to be compared one by one.\nSo, when we changed the object, we used immutable data that guarantees that the reference is also changed,\nand we use ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," because it guarantees that the object is immutable with any changes. "),(0,o.kt)("p",null,"Even if you have never consciously used an ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),", if you are using a ",(0,o.kt)("inlineCode",{parentName:"p"},"redux-toolkit")," to use ",(0,o.kt)("inlineCode",{parentName:"p"},"redux"),", you are already using an ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"Before deep dive to immer, Let's show check to use ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),".\nNext is the example in ",(0,o.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/#a-quick-example-for-comparison"},"immer docs"),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The compare way to update baseState immutably")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'const baseState = [\n  {\n    title: "Learn TypeScript",\n    done: true\n  },\n  {\n    title: "Try Immer",\n    done: false\n  }\n]\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// without immer\nconst nextState = baseState.slice()\n\nnextState[1] = { \n  ...nextState[1], \n  done: true, \n}\nnextState.push({ title: 'Tweet about it' })\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'// with immer\nimport produce from "immer"\n\nconst nextState = produce(baseState, draft => {\n    draft[1].done = true\n    draft.push({ title: "Tweet about it" })\n})\n')),(0,o.kt)("p",null,"If we don't use ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),", we need to do copy \u2192 update process and need to check if object is changed mutably or not.\nBut, if we use ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),", it can be ensured that data is immutable no matter how we use it."),(0,o.kt)("p",null,"If you have never been used an ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," yourself and used the ",(0,o.kt)("inlineCode",{parentName:"p"},"redux")," using the ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/"},"redux-toolkit"),",\nyou are already using the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),".\nIf you're not sure, ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createReducer#direct-state-mutation"},"read this document")," on how to mutate the state in the redux-toolkit"),(0,o.kt)("h2",{id:"about-immer-before-deep-dive"},"About immer before deep-dive"),(0,o.kt)("p",null,"First, I will talk about the principle of ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),".\nThe contents described here will be easier to understand by referring to the article of the ",(0,o.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/#how-immer-works"},"document of immer"),"\nand ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3#3bff"},"the blog article")," linked to the FAQ of documents. "),(0,o.kt)("h3",{id:"immer-doesnt-update-original-data"},"immer doesn't update original data"),(0,o.kt)("p",null,"When update data, ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," doesn't update original data(",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),").\nBut it create copy data(",(0,o.kt)("inlineCode",{parentName:"p"},"copy_"),") using ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and update ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," instead of updating original data.\nUsing this principle, the updated data is returned without changing the original data."),(0,o.kt)("h3",{id:"immer-record-if-object-is-updated-or-not"},"immer record if object is updated or not"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"immer")," set ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," flag to ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," when update object.\nIf deep part of object tree is modified, ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," update ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," flag from deep part to root tree.\nThen ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," can traverse root to lear tree. "),(0,o.kt)("p",null,"After completing the object update process, ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," check the ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," flag.\nIf object is modified, use copy data(",(0,o.kt)("inlineCode",{parentName:"p"},"copy_"),").\nIf it is not modified, the structural share is used by reusing the existing reference using original data(",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),")."),(0,o.kt)("h3",{id:"recap"},"Recap"),(0,o.kt)("p",null,"In short, It is summarized in three lines."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Manage two type of object, ",(0,o.kt)("inlineCode",{parentName:"li"},"original data")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"copy data"),", preserve original data and update copy data only."),(0,o.kt)("li",{parentName:"ul"},"The changed object can be traversed from the root tree to the leaf tree by turning on the modified flag."),(0,o.kt)("li",{parentName:"ul"},"After the update is completed, the process of combining the new and existing objects using the modified flag is performed.")),(0,o.kt)("h2",{id:"deep-dive-to-immer"},"Deep dive to immer"),(0,o.kt)("p",null,"Let's deep dive to immer. ",(0,o.kt)("br",null),"\nTo check logic of ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),", we need to checking ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function used in usage first."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/immer.ts#L23-L45\nconst immer = new Immer();\nexport const produce = immer.produce;\nexport default produce;\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function is method function of ",(0,o.kt)("inlineCode",{parentName:"p"},"Immer")," class. Let's see inner ",(0,o.kt)("inlineCode",{parentName:"p"},"Immer")," class."),(0,o.kt)("p",null,"Excluding the curring function handling and several exception cases in the ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function, it is reduced as follows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/immerClass.ts#L66-L122\nexport class Immer {\n  produce: (base, recipe) => { \n    let result;\n\n    const scope = enterScope(this);\n    const proxy = createProxy(this, base, undefined);\n    \n    result = recipe(proxy);\n\n    return processResult(result, scope);     \n  }\n}\n")),(0,o.kt)("p",null,"Since the ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function is simpler than excepted, let's move on to the order of the ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function logic."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"produce")," function receives parameters that existing object(",(0,o.kt)("inlineCode",{parentName:"li"},"base"),") and the function that determines how to update the object(",(0,o.kt)("inlineCode",{parentName:"li"},"recipe"),")."),(0,o.kt)("li",{parentName:"ol"},"Create ",(0,o.kt)("inlineCode",{parentName:"li"},"scope"),"."),(0,o.kt)("li",{parentName:"ol"},"Create ",(0,o.kt)("inlineCode",{parentName:"li"},"proxy"),"."),(0,o.kt)("li",{parentName:"ol"},"Run ",(0,o.kt)("inlineCode",{parentName:"li"},"recipe")," using ",(0,o.kt)("inlineCode",{parentName:"li"},"proxy"),"."),(0,o.kt)("li",{parentName:"ol"},"Return the final object updated using ",(0,o.kt)("inlineCode",{parentName:"li"},"processResult"),".")),(0,o.kt)("p",null,"What should be questioned here is that the logic of mutable updating is included ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," function is just called only.\nBut the logic of mutable updating inner ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," does immutable update without updating target object directly."),(0,o.kt)("p",null,"The secret may be ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy"),". In fact, when creating a proxy, it uses a ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"new Proxy"),",\nwhich acts as a key point for the main logic of the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("p",null,"Let's take a look one by one."),(0,o.kt)("h3",{id:"scope"},"scope"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"scope")," is an object that stores information to be used throughout the immer.\nIt is not used much in the basic logic of the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/scope.ts#L33-L46\nfunction createScope(\n  parent_: ImmerScope | undefined,\n  immer_: Immer\n): ImmerScope {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  }\n}   \n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"drafts_")," is an array that is contained one by one when creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," that is made later\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"immer_")," is a space that contains an immer class."),(0,o.kt)("h3",{id:"proxy"},"proxy"),(0,o.kt)("p",null,"Let's check ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy"),", which is the core of the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"immer")," responds not only to objects but also to cases where Array, Map, Set and proxy can't be used(ES5),\nso the code seems complicated, but if we look at it only with objects, logic becomes a little simpler."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/immerClass.ts#L212-L229\nexport function createProxy(immer, value, parent) {\n  const draft = createProxyProxy(value, parent);\n  const scope = getCurrentScope();\n  \n  scope.drafts_.push(draft);\n  return draft;\n}\n")),(0,o.kt)("p",null,"To know how to create ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy"),", we need to check ",(0,o.kt)("inlineCode",{parentName:"p"},"createProxyProxy")," function.\nThe focus point here is that the generated proxy is put in ",(0,o.kt)("inlineCode",{parentName:"p"},"scope.drafts_"),".\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," first created is root proxy. So ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," will use ",(0,o.kt)("inlineCode",{parentName:"p"},"scope.drafts_[0]")," when get ",(0,o.kt)("inlineCode",{parentName:"p"},"rootProxy")," later."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/proxy.ts#L50-L95\nexport function createProxyProxy(base, parent) {\n  const state = {\n    ...\n    scope_: getCurrentScope(),\n    modified_: false,\n    finalized_: false,\n    parent_: parent,\n    base_: base,\n    draft_: null,\n    copy_: null,\n    ...\n  }\n\n  const target = state;\n  const traps = objectTraps\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke\n  \n  return proxy;\n} \n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"createProxyProxy"),", various metadata and new ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," objects are created to be used for immer operation.\nThe metadata used in the immer is summarized as follows."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"base_"),": Existing data. It came in as the first parameter in ",(0,o.kt)("inlineCode",{parentName:"li"},"produce")," and the original data before it is changed is stored here."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"copy_"),": Updated data. Updated data is saved here using original data and ",(0,o.kt)("inlineCode",{parentName:"li"},"recipe"),". It doesn't have any data yet."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"draft_"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"draft_")," save ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy")," object that will create here. In the future logic, data is referred to in the same way as ",(0,o.kt)("inlineCode",{parentName:"li"},"draft_.base")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"draft_.copy"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"modified_"),": It stores whether the object has been changed. Default value is ",(0,o.kt)("inlineCode",{parentName:"li"},"false")," because object is not updated."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"finalized_"),": It stores whether the proxy complete to update and ready to be returned. Default value is ",(0,o.kt)("inlineCode",{parentName:"li"},"false")," because the object is being prepared. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"parent_"),": Object can be multi depth. If object composed tree form, parent tree is saved here. This is empty in root proxy.")),(0,o.kt)("p",null,"The main metadata is summarized above.\nThe default value of metadata is set here and ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," object is created by ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy.revocable")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"traps"),".\nLet's see about Proxy in next chapter. "),(0,o.kt)("admonition",{title:"Terms",type:"info"},(0,o.kt)("h3",{parentName:"admonition",id:"proxy-proxy"},"proxy? Proxy?"),(0,o.kt)("p",{parentName:"admonition"},"From now on, I will mention the variable ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," that includes the ",(0,o.kt)("inlineCode",{parentName:"p"},"new Proxy")," object, including metadata,\nand also will mention the object ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," to control various basic actions against objects in javascript as the terms implies.\nCoincidentally, since the two terms are the same term as \"proxy\", in this article, the two will be divided into 'p' as follows. "),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"proxy"),": The object containing metadata generated by ",(0,o.kt)("inlineCode",{parentName:"li"},"immer")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"draft")," generated by ",(0,o.kt)("inlineCode",{parentName:"li"},"new Proxy"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Proxy"),": built-in object served by javascript. It is used as an object to control various basic traps of an object."))),(0,o.kt)("h3",{id:"new-proxy"},"new Proxy"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"In this chapter, we have a time to know what is the ",(0,o.kt)("a",{parentName:"em",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"new Proxy"),"\nIf you are familiar with ",(0,o.kt)("inlineCode",{parentName:"em"},"Proxy"),", it doesn't matter if you ",(0,o.kt)("a",{parentName:"em",href:"#traps-of-immer"},"move on to the next chapter")))),(0,o.kt)("p",null,"We created ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," object using ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy.revocable")," in previous chapter."),(0,o.kt)("p",null,"The definition of Proxy in ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"MDN docs")," is following."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," object create new Object that intercept or redefine feature of object like set or get.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Immer")," uses ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," to intercept logic to update the original object in a different way, rather than directly updating the object\nwhen getting and setting the original object by creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," object with the original object."),(0,o.kt)("p",null,"For example, if you have an object and want to dobule the value you set when you set it, you can use it as follows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const origin = {};\nconst handler = {\n  set: function(target, prop, value) {\n    if (typeof value === 'number') {\n      target[prop] = value * 2;\n    } else {\n      Reflect.set(...arguments);\n    }\n  }\n}\n\nconst proxy = new Proxy(origin, handler);\n\nproxy.a = 10;\nproxy.b = {};\n\nconsole.log(proxy.a); // 20\nconsole.log(proxy.b); // {}\n")),(0,o.kt)("p",null,"When assign to ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.a"),", the normal set of objects is not used, but the logic of ",(0,o.kt)("inlineCode",{parentName:"p"},"handle.set")," registered when creating the ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," object is used.\nBecause the value to set is 10, ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.a")," is saved 20 not 10.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Reflect"),", which is used in the operation when the value is not the number, is used to follow the existing logic. "),(0,o.kt)("p",null,"Now, what if an additional value is allocated to the object ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.b"),"?\nWill 40 be assigned? Or will 20 be assigned?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"proxy.b.c = 20\n\nconsole.log(proxy.b.c) // 20? 40?\n")),(0,o.kt)("p",null,"The answer is 20. The reason is that ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," is a Proxy object, but ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.b")," is not a Proxy object but a plain object.\nTherefore, 20 is allocated as it is using a set of plain object without using ",(0,o.kt)("inlineCode",{parentName:"p"},"handle.set"),"."),(0,o.kt)("p",null,"This action acts critically in the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),".\nThis is because there will be many cases in which child objects\nthat become several depth are immediately changed in the process of updating the object. "),(0,o.kt)("p",null,"Therefore, it responds in the following ways."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const origin = {};\nconst handler = {\n  set: function(target, prop, value) {\n    if (typeof value === 'number') {\n      target[prop] = value * 2;\n    } else {\n      Reflect.set(...arguments);\n    }\n  },\n  // highlight-start\n  get: function(target, prop) {\n    if (typeof target[prop] === 'object') {\n      return new Proxy(target[prop], handler);\n    }\n    \n    return Reflect.get(...arguments);\n  }\n  // highlight-end\n}\n\nconst proxy = new Proxy(origin, handler);\n\nproxy.b = {};\nproxy.b.c = {};\nproxy.b.c.d = 20;\n\nconsole.log(proxy.b.c); // Proxy {}\nconsole.log(proxy.b.c.d); // 40\n")),(0,o.kt)("p",null,"When create Proxy, we add custom logic not only get but also set.\nWhen getting a value from a Proxy object, if it is normal object, it create and get a proxy object.\nIn this case, the Proxy object is also a Proxy object, and ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.b")," also returns the Proxy object, not the general object, using ",(0,o.kt)("inlineCode",{parentName:"p"},"handler.get"),".\nTherefore, if 20 is assigned to ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.b.c"),", 40 is allocated in ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.b.c")," not 20 because ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.b")," is Proxy object. "),(0,o.kt)("p",null,"Using these actions of get and set, ",(0,o.kt)("inlineCode",{parentName:"p"},"Immer")," uses logic using ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," without directly updating the object\nin the set so that even when referring to deep objects in get, Proxy can be referenced.\nLet's find out how it is implemented in the next chapter."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"About ",(0,o.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"latest")," and ",(0,o.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"peek")),(0,o.kt)("p",{parentName:"admonition"},"From now on, we may be meet a lot about ",(0,o.kt)("inlineCode",{parentName:"p"},"latest")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"peek"),", which are the util functions used in the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," code.\nIf you're curious about what this function does, let's take a look."),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"latest")),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/master/src/utils/common.ts#L160-L162\nexport function latest(state) {\n  return state.copy_ || state.base_\n}\n")),(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"state")," is proxy object created in ",(0,o.kt)("inlineCode",{parentName:"p"},"produce"),". proxy object has metadata and object that is created by ",(0,o.kt)("inlineCode",{parentName:"p"},"new Proxy"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"latest")," brings in a ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," object, and it can be seen that it is currently used to bring data held by proxy.\n",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is the latest object updated and ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," is original object so the priority is to bring ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," first."),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"peek")),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/master/src/core/proxy.ts#L234-L238\nexport function peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop]\n}\n")),(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"peek")," has role to bring value of specific key in object. In other word, It is used to bring key matched prop in draft.\nThere are three cases here."),(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},"When draft is plain object not Proxy object.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"In this case, It return immediately with reference to ",(0,o.kt)("inlineCode",{parentName:"li"},"draft[prop]")," because ",(0,o.kt)("inlineCode",{parentName:"li"},"draft[DRAFT_STATE]")," is ",(0,o.kt)("inlineCode",{parentName:"li"},"undefined"),"."))),(0,o.kt)("li",{parentName:"ol"},"When draft is Proxy object and has ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Returns ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_.[prop]"),"."))),(0,o.kt)("li",{parentName:"ol"},"When draft is PRoxy object and doesn't have ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Returns ",(0,o.kt)("inlineCode",{parentName:"li"},"base_.[prop]"),".")))),(0,o.kt)("p",{parentName:"admonition"},"In other word, it is util function to get value to match key from object(or proxy) for several case.  ")),(0,o.kt)("h3",{id:"traps-of-immer"},"Traps of immer"),(0,o.kt)("p",null,"immer\uc758 ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy"),"\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 get\uc740 multi depth\uc758 \uac1d\uccb4\ub97c \ucc38\uc870\ud588\uc744\ub54c\uc5d0\ub3c4 Proxy\ub97c \ucc38\uc870\ud560 \uc218 \uc788\uac8c Proxy\ub97c \uc0dd\uc131\ud574\uc8fc\ub294 \uc5ed\ud560\uc744 \uac00\uc9c0\uace0 \uc788\uace0,\nset\uc740 \uc6d0\ubcf8 \uac1d\uccb4\ub97c \ubcc0\uacbd\ud558\ub824 \ud560 \ub54c \uc774\ub97c \ub9c9\uace0 ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_"),"\uc640 \uac19\uc740 \uba54\ud0c0 \ub370\uc774\ud130\ub97c \uc81c\uc5b4\ud558\ub3c4\ub85d \ud558\ub294 \uc5ed\ud560\uc744 \uac00\uc9c0\uace0 \uc788\ub2e4."),(0,o.kt)("h4",{id:"get"},"Get"),(0,o.kt)("p",null,"The purpose of logic of get is that create proxy object to use it even if we access deep tree directly. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/master/src/core/proxy.ts#L101-L124\nexport const objecTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n\n    const source = latest(state);\n    const value = source[props];\n    \n    if (state.finalized_ || !isDraftable(value)) return value    \n\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state)\n    }\n    \n    return value\n  }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (prop === DRAFT_STATE) return state;\n")),(0,o.kt)("p",null,"This first ",(0,o.kt)("inlineCode",{parentName:"p"},"DRAFT_STATE")," condition logic seems hole logic to get draft from ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," immediately.\nWe can check that it brings proxy by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"draft[DRAFT_STATE]")," in utils function like ",(0,o.kt)("inlineCode",{parentName:"p"},"peek"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const source = latest(state);\nconst value = source[prop];\n    \nif (state.finalized_ || !isDraftable(value)) return value  \n")),(0,o.kt)("p",null,"Next logic is condition when we don't need to create proxy object.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"finalized")," status, that is, the data is all updated and ready to return.\nOr the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"isDraftable"),", that is, if it is not a type such as object or array with mutable,\nthere is no reason to make it a proxy, so it returns as it is."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (value === peek(state.base_, prop)) {\n  prepareCopy(state);\n  return state.copy_[prop] = createProxy(state.scope_.immer_, value, state)\n}\n\nreturn value\n")),(0,o.kt)("p",null,"Now, This is logic when creates proxy object.\nIt calls ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," and create child proxy in ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," is the function that do shallow copy from ",(0,o.kt)("inlineCode",{parentName:"p"},"state.base_")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"state.copy_"),".\nIt creates ",(0,o.kt)("inlineCode",{parentName:"p"},"state.copy_")," by coping and saves new proxy in ",(0,o.kt)("inlineCode",{parentName:"p"},"state.copy_[prop]"),".\nSince then, The values of ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is not same. "),(0,o.kt)("p",null,"Through these logics, even if we refer to the deep tree, it is implemented so that we can get proxy object if it is an object."),(0,o.kt)("p",null,"So, if we refer back to the object that we have created proxy with get, should we create proxy object again?\nOf course, once an object that has created a proxy, it reused what has been made.\nThe logic that checks for reuse is condition of ",(0,o.kt)("inlineCode",{parentName:"p"},"value === peek(state.base_, prop)"),"."),(0,o.kt)("h5",{id:"reuse-of-already-created-proxy-value--peekstatebase_-prop"},"reuse of already created proxy (",(0,o.kt)("inlineCode",{parentName:"h5"},"value === peek(state.base_, prop)"),")"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"peek(state.base_, prop)")," means ",(0,o.kt)("inlineCode",{parentName:"p"},"prop")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," means ",(0,o.kt)("inlineCode",{parentName:"p"},"prop")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),".\nBefore ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is created, that is, if we have never done ",(0,o.kt)("inlineCode",{parentName:"p"},"get"),", it always compares ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),"\nso it is always ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," and always run logic to create proxy.\nHowever, if we have done ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is created, it compares ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),".\nSince the previous get logic allocates proxy to ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_[prop]")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is already different from ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),",\nthe logic of creating ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," is skipped and the ",(0,o.kt)("inlineCode",{parentName:"p"},"state.copy_")," is returned as it is."),(0,o.kt)("p",null,"To use this way, ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," prevent unnecessary to create ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"get"),". "),(0,o.kt)("p",null,"It is complicated to explain one line at a time by code,\nbut summarize what we do in the ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," logic of proxy."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"If the referred value from object is not object, it just return it is."),(0,o.kt)("li",{parentName:"ol"},"If the referred value from object is object, create and return proxy."),(0,o.kt)("li",{parentName:"ol"},"If it is an object that has been referenced once, reuse the previously created proxy.")),(0,o.kt)("h4",{id:"set"},"Set"),(0,o.kt)("p",null,"The purpose of set logic is to update an object and set a ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," flag that the object is updated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/master/src/core/proxy.ts#L131-L173\nexport const objectTraps = {\n  set(state, prop, value) {\n    if (!state.modified_) {\n      const current = peek(latest(state), prop)\n      const currentState = current?.[DRAFT_STATE]\n      \n      if (is(value, current) && has(state.base_, prop)) return;\n\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    if (state.copy[props] === value) return;\n\n    state.copy_[props] = value;\n    return;\n  }\n} \n")),(0,o.kt)("p",null,"The abbreviation of the main logic used in the set is as above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"set() {\n  ...\n  if (state.copy[props] === value) return;\n\n  state.copy_[props] = value;\n  return;  \n}\n")),(0,o.kt)("p",null,"Looking at the logic that proceeds regardless of whether it is ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_"),",\nit can be seen that only ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is changed without changing the original data(",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),") when setting."),(0,o.kt)("p",null,"In this process, we can see that if new value has the same reference as the value stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_"),",\nit doesn't do update. As a result, it can also be confirmed that unnecessary updates are being prevented."),(0,o.kt)("p",null,"If object to be updated has no changed history, ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," would be false, but the ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," flag is changed in set logic."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"set(state, prop, value) {\n  if (!state.modified_) {\n    const current = peek(latest(state), prop)\n    const currentState = current?.[DRAFT_STATE]\n    \n    if (is(value, current) && has(state.base_, prop)) return;\n\n    // highlight-start\n    prepareCopy(state);\n    markChanged(state);\n    // highlight-end\n  }\n  ...\n}\n")),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," is false when proceeding with the set, the change logic is performed.\nExcept for edge logic, if we look at basic logic, it perform the functions ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"markChanged"),". "),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("h4",{parentName:"admonition",id:"preparecopy-from-get-and-preparecopy-from-set"},(0,o.kt)("inlineCode",{parentName:"h4"},"prepareCopy")," from get and ",(0,o.kt)("inlineCode",{parentName:"h4"},"prepareCopy")," from set"),(0,o.kt)("p",{parentName:"admonition"},"Previously, we saw the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," when proceeding with get.\nDoes it do copy when we get and copy when we set?"),(0,o.kt)("p",{parentName:"admonition"},"If we look closely, ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," of get and ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," of set have different purposes."),(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," do that copy parent object about referred object\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),"do that copy itself about referred object."),(0,o.kt)("p",{parentName:"admonition"},"For example, if the object is changed to ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.a.b = { ... }"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is made through ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," from get to ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.a"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy.a.b")," makes ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"prepareCopy")," in the set.")),(0,o.kt)("p",null,"The code of ",(0,o.kt)("inlineCode",{parentName:"p"},"markChanged")," is as follows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/proxy.ts#L266-L273\nexport function markChanged(state: ImmerState) {\n  if (!state.modified_) {\n    state.modified_ = true\n    if (state.parent_) {\n      markChanged(state.parent_)\n    }\n  }\n}\n")),(0,o.kt)("p",null,"In addition to changing one's ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," to the root proxy through the ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," of the parent object is changed.\nBy changing the root proxy in this way, it is possible to find which object has been changed from root to leaf."),(0,o.kt)("p",null,"In addition, let's check the edge case when changing ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," that was missed in the middle."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"set(state, prop, value) {\n  if (!state.modified_) {\n    // highlight-start\n    const current = peek(latest(state), prop)\n    const currentState = current?.[DRAFT_STATE]\n    \n    if (is(value, current) && has(state.base_, prop)) return;\n    // highlight-end\n\n    prepareCopy(state);\n    markChanged(state);\n  }\n  ...\n")),(0,o.kt)("p",null,"If the value to be changed is the same as the stored value and the value ",(0,o.kt)("inlineCode",{parentName:"p"},"base_[props]")," exist,\nit is determined that there is no need to change it.\nThe process of updating ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," true is stopped and updates are not performed.\nIt seems to be an effort to reduce unnecessary cost by not changing ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," when the same value is allocated."),(0,o.kt)("p",null,"Now, the logic of the set is summarized as follows."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"modified_")," is false, copies from ",(0,o.kt)("inlineCode",{parentName:"li"},"base_")," to ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_")," itself and updates ",(0,o.kt)("inlineCode",{parentName:"li"},"modified_")," from parents to root including oneself true."),(0,o.kt)("li",{parentName:"ol"},"Regardless of whether it is modified or not, it allocates a value to be changed to ",(0,o.kt)("inlineCode",{parentName:"li"},"state.copy_"),". ")),(0,o.kt)("h3",{id:"recap-of-proxy"},"Recap of Proxy"),(0,o.kt)("p",null,"Let's summarize the role of proxy objects in the immer."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When referring to data, if it is an object, it creates a proxy object.\nWhen referred to multiple depth in an object several times, get proceeds sequentially,\nso all objects from root object to target object are generated as proxy.\nThanks to this, when referring to objects in multi depth, the same proxy logic as the root can be used."),(0,o.kt)("li",{parentName:"ul"},"When allocating data, ",(0,o.kt)("inlineCode",{parentName:"li"},"base_")," is shallowly copied to ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_")," and a value is updated to the object ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_")," is updated.\nIn this case, if an object that has not been updated is updated, all modifications from the object to the root object through the parent object are set to true. ")),(0,o.kt)("h2",{id:"finalize"},"finalize"),(0,o.kt)("p",null,"If all data have been updated through the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," function, the finalization process is now performed.\nIt is a process of appropriately combining ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_"),"."),(0,o.kt)("p",null,"Looking at the product code again, it is as follows. ",(0,o.kt)("br",null),"\nHere, the logic for ",(0,o.kt)("inlineCode",{parentName:"p"},"processResult(result, scope)")," is confirmed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/immerClass.ts#L66-L122\nexport class Immer {\n  produce: (base, recipe) {\n    let result;\n\n    const scope = enterScope(this);\n    const proxy = createProxy(this, base, undefined);\n    \n    result = recipe(proxy);\n    // highlight-start\n    return processResult(result, scope);\n    // highlight-end\n  }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/finalize.ts#L22-L56\nexport function processResult(result, scope) {\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== undefined;\n  \n  if (isReplaced) {\n    result = finalize(scope, result);\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," process is largely divided into two. This is the case of returning in ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," or not.\nThe difference between these two lies in the variable that is put as a function of ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize"),".\nIf ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," is returning, ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," do based on the result value.\nIf ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," is not returning, ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," do based on the root proxy."),(0,o.kt)("h3",{id:"using-finalize-with-root-proxy"},"using finalize with root proxy"),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," is not returning, ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," is automatically performed using root proxy."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/finalize.ts#L57-L110\nfunction finalize(rootScope, value, path) {\n  ...\n  if (!state.modified_) {\n    return state.base_;\n  }\n  \n  if (!state.finalized_) {\n    state.finalized_ = true;\n    const result = state.copy_;\n    \n    each(result, (key, childValue) => finalizeProperty(...));\n  }\n  \n  return state.copy_;\n}\n")),(0,o.kt)("p",null,"In here, value means root proxy. If root proxy has ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," as false, it means that the internal object has never been changed.\nTherefore, It returns ",(0,o.kt)("inlineCode",{parentName:"p"},"state.base_")," as it is.\nIt ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," is true because it has been changed, ",(0,o.kt)("inlineCode",{parentName:"p"},"finalized")," is checked. To prevent the finalized logic from being performed several times,\nwhen the finalized logic is entered, the ",(0,o.kt)("inlineCode",{parentName:"p"},"finalized_")," is changed to true and the logic proceeds.\nIn ES5 mode that does not use proxy, several logics proceed, but in proxy mode, ",(0,o.kt)("inlineCode",{parentName:"p"},"state.copy_")," is used as it is.\n",(0,o.kt)("inlineCode",{parentName:"p"},"finalizeProperty")," including ",(0,o.kt)("inlineCode",{parentName:"p"},"each")," is an operation to ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," all child objects inside the root proxy.\nIf the finalization of all child objects is completed, the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," logic ends by returning ",(0,o.kt)("inlineCode",{parentName:"p"},"state.copy_"),"."),(0,o.kt)("h3",{id:"using-finalize-with-return-of-recipe"},"using finalize with return of recipe"),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," has a return value, ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," is performed using the return value. Of course, the return value is a plane object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// https://github.com/immerjs/immer/blob/v9.0.6/src/core/finalize.ts#L57-L110\nfunction finalize(rootScope, value, path) {\n  const state = value[DRAFT_STATE];\n  \n  if (!state) {\n    each(value, (key, childValue) => finalizeProperty(...))\n    return value;\n  }\n  ...\n}\n")),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," refers ",(0,o.kt)("inlineCode",{parentName:"p"},"value[DRAFT_STATE]")," in value of plain object, It has to be undefined.\nTherefore, it proceeds to the logic of ",(0,o.kt)("inlineCode",{parentName:"p"},"if (!state)"),".\nIn the same way as ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," using root proxy, all child objects are finalized through ",(0,o.kt)("inlineCode",{parentName:"p"},"finalizeProperty")," and then the value is returned."),(0,o.kt)("p",null,"In this time, all child objects may be considered to be plain objects, not proxy objects,\nbut since all objects approaching inside ",(0,o.kt)("inlineCode",{parentName:"p"},"recipe")," are changed to proxy and returned by proxy's get operation,\nthe child object may be proxy even if the root is not proxy.\nTherefore, it is necessary to proceed with finalize all child objects."),(0,o.kt)("h2",{id:"recap-1"},"Recap"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"immer")," receives the ",(0,o.kt)("inlineCode",{parentName:"li"},"baseState")," object and the ",(0,o.kt)("inlineCode",{parentName:"li"},"recipe")," callback function and performs both the mutable logic inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"recipe"),",\nwhich returns the updated new object without changing the existing object."),(0,o.kt)("li",{parentName:"ul"},"When receive ",(0,o.kt)("inlineCode",{parentName:"li"},"baseState"),", first ",(0,o.kt)("inlineCode",{parentName:"li"},"immer")," creates ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy")," object using ",(0,o.kt)("inlineCode",{parentName:"li"},"baseState")," and manages it."),(0,o.kt)("li",{parentName:"ul"},"Although the proxy object has several data, but main data are ",(0,o.kt)("inlineCode",{parentName:"li"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_"),".\nIt is managed that ",(0,o.kt)("inlineCode",{parentName:"li"},"base_")," is original data and ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_")," is updated data.  "),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"recipe")," callback function logic is executed with the previously created proxy object,\nwhere the method of not performing mutable logic is because it intercepts basic object actions such as proxy's set and get."),(0,o.kt)("li",{parentName:"ul"},"In the get of ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy"),", all the objects it meets are returned to ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy")," so that it can create ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy")," even if we refer to the depth of the object."),(0,o.kt)("li",{parentName:"ul"},"In the set of ",(0,o.kt)("inlineCode",{parentName:"li"},"Proxy"),", the ",(0,o.kt)("inlineCode",{parentName:"li"},"modified_")," flag managed inside the proxy object is viewed to manage whether to change or not,\nand the ",(0,o.kt)("inlineCode",{parentName:"li"},"copy_")," object, not the ",(0,o.kt)("inlineCode",{parentName:"li"},"base_")," object, is updated."),(0,o.kt)("li",{parentName:"ul"},"After performing both proxy logic using set and get of proxy in the ",(0,o.kt)("inlineCode",{parentName:"li"},"immer"),",\nthe changed object uses the information of the proxy object to use the updated object(",(0,o.kt)("inlineCode",{parentName:"li"},"copy_"),")\nand the unchanged object uses the original object(",(0,o.kt)("inlineCode",{parentName:"li"},"base_"),") to create and return a new object.")),(0,o.kt)("h2",{id:"answer-the-question"},"Answer the question"),(0,o.kt)("admonition",{title:"Question",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Q1. How does ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," change the mutable update way to immutable update way?")),(0,o.kt)("p",null,"A1. Because ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," is intercepting get and set logic to using ",(0,o.kt)("inlineCode",{parentName:"p"},"new Proxy"),",\nObject is not mutated directly even if update object mutably.\nIn the logic of set, the ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," is copied from ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," updates ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," without changing ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),". "),(0,o.kt)("p",null,"After all updates are completed, it is possible to immutably update the object\nby determining whether the object has been changed and returning ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),"."),(0,o.kt)("admonition",{title:"Question",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Q2. How does ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," use ",(0,o.kt)("inlineCode",{parentName:"p"},"structural sharing"),"?")),(0,o.kt)("p",null,"A2. ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," manages the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," according to whether the object is changed.\nIf ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," is true, it means that object is updated.\nIf ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," is true, return a new object called ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," to use a new reference,\nIf ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," is false, ",(0,o.kt)("inlineCode",{parentName:"p"},"base_")," object, original object, is returned with previous reference.",(0,o.kt)("br",{parentName:"p"}),"\n","Therefore, boolean is managed whether it has been changed or not,\nand structural sharing is used to use the existing one or the new one depending on whether it has been changed."),(0,o.kt)("admonition",{title:"Question",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Q3. ",(0,o.kt)("inlineCode",{parentName:"p"},"immer")," sometimes updates data through return rather than mutable updating the draft within ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function,\nin which case the logic is different?")),(0,o.kt)("p",null,"Whether to return within the ",(0,o.kt)("inlineCode",{parentName:"p"},"produce")," function differs in the ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),", in the process of preparing the updated object.\nIf return is not made, it means that the object has been directly changed inside ",(0,o.kt)("inlineCode",{parentName:"p"},"produce"),",\nand if so, using the proxy logic get, set implemented by immer, it is that the object has been updated.\nThen, Object updates are carried out using various variables and logics such as ",(0,o.kt)("inlineCode",{parentName:"p"},"base_"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"copy_")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," as discussed in this article."),(0,o.kt)("p",null,"However, what would happen if I returned?\nIf there is a return value in ",(0,o.kt)("inlineCode",{parentName:"p"},"produce"),", it means that the result value is returned as it is without using logic such as proxy get and set prepared by ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),".\nTherefore, it skips all logic and moves on to the ",(0,o.kt)("inlineCode",{parentName:"p"},"finalize")," process, such as forming a root proxy, updating objects through get, and changing ",(0,o.kt)("inlineCode",{parentName:"p"},"modified_")," to set.\nThis means returning results without using most of the ",(0,o.kt)("inlineCode",{parentName:"p"},"immer"),"'s logic."),(0,o.kt)("p",null,"Both methods manage objects immutably and update them.\nAnd both methods use structural sharing in which only the changed object changes its reference.\nOf course, if you use the second method, the method of returning the updated object,\nyou need to be careful not to create a new object unnecessarily.\nAs a result, either side is the same.\nTo choose the difference, it is only about hot to change the object. If so, it is an area of choice.\nYou can think about whether to choose a method of changing it to be mutable or immutable."),(0,o.kt)("p",null,"Of course, speaking of my opinion, I think the way we update an object depends on the purpose of how we want to update it.\nTherefore, I think we can understand the advantages and disadvantages of changing to immutable and the advantages and disadvantages of changing to mutable,\nand mix them according to the situation."),(0,o.kt)("h2",{id:"reference"},"Reference"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://immerjs.github.io/immer/"},"immer official docs")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/immerjs/immer/tree/v9.0.6"},"immer repository v9.0.6")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://ko.redux.js.org/style-guide/style-guide/#use-redux-toolkit-for-writing-redux-logic"},"redux style guide")," "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://redux-toolkit.js.org/api/createReducer#direct-state-mutation"},"redux-toolkit guide")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3#3bff"},"[blog] Introducing immer: Immutability the easy way")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"Proxy MDN"))))}u.isMDXComponent=!0}}]);