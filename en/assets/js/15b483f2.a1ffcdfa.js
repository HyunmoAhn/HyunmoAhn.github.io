"use strict";(self.webpackChunkhyunmoahn_github_io=self.webpackChunkhyunmoahn_github_io||[]).push([[4766],{9283:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"how-to-use-oas-generator","metadata":{"permalink":"/en/how-to-use-oas-generator","source":"@site/i18n/en/docusaurus-plugin-content-blog/2022-03-28-how-to-use-oas-generator-in-front-end.mdx","title":"How to use OAS generator in Front-end environment?","description":"OAS generator","date":"2022-03-28T00:00:00.000Z","formattedDate":"March 28, 2022","tags":[{"label":"OAS","permalink":"/en/tags/oas"},{"label":"OAS-generator","permalink":"/en/tags/oas-generator"},{"label":"typescript","permalink":"/en/tags/typescript"},{"label":"typescript-axios","permalink":"/en/tags/typescript-axios"},{"label":"how-to-use","permalink":"/en/tags/how-to-use"},{"label":"web","permalink":"/en/tags/web"}],"readingTime":19.885,"truncated":true,"authors":[{"name":"Hyunmo Ahn","title":"Front End Engineer @ Line Financial+","url":"https://github.com/HyunmoAhn","imageURL":"https://github.com/HyunmoAhn.png","key":"HyunmoAhn"}],"frontMatter":{"slug":"how-to-use-oas-generator","title":"How to use OAS generator in Front-end environment?","description":"OAS generator","keywords":["OAS","OAS-generator","typescript","typescript-axios","how-to-use","web"],"authors":"HyunmoAhn","tags":["OAS","OAS-generator","typescript","typescript-axios","how-to-use","web"]},"nextItem":{"title":"Deep dive to immer","permalink":"/en/deep-dive-to-immer"}},"content":"I am using OAS-generator in project recently.\\nWhen deciding to use it, there were many things that required consideration and confirmation.\\nAnd, I\'m going to write about my experience using OAS-generator because it seems to have a lot of good things after using.\\n\\nPerhaps those who are curious about what OAS-generator is, those who know but are worried about using it,\\nand those who are already using it but are hesitant to use it well,\\nI hope that you will learn good motifs and experiences by reading this article.\\n\\nWhat this article says is as follows.\\n- What is the OAS-generator.\\n- The pros and cons of using OAS-generator.\\n- How to use OAS-generator.\\n  - Configuration\\n  - Custom Templates\\n- Optimization\\n\\n:::info Pre-required\\n- The experience to develop front-end using Rest API\\n- Can read the mustache [Grammar](https://github.com/janl/mustache.js)(Optional)\\n  - Even if you don\'t know, there\'s no problem reading this article. But, you want to use OAS-generator, you should know it.\\n:::\\n\\n\x3c!--truncate--\x3e\\n\\n\\n## OAS Generator, What is it?\\nBefore to know OAS Generator, Let to know what is the `OAS`.\\n### OAS? Open Api Specification\\n`OAS` is abbreviation of `Open Api Specification`.\\n\\n> The OpenAPI Specification (OAS) is a vendor neutral description format for HTTP-based remote APIs.\\n\\nIf you can see [The document about OAS](https://oai.github.io/Documentation/introduction.html),\\nOAS is said to have named a rule for writing documents that both machines and people can understand about HTTP-based APIs.\\nFor example, when you click that link as shown in the image below in [the swagger document](https://petstore.swagger.io/),\\nit connects to [the OAS document](https://petstore.swagger.io/v2/swagger.json).\\nThe [JSON](https://petstore.swagger.io/v2/swagger.json) or yaml files consisting of text are OAS(Open Api Specification).\\n\\n![swagger-to-oas-docs](/assets/oas-generator/swagger.png)\\n\\n![swagger-to-oas-docs-oas-result](/assets/oas-generator/oas-json.png)\\n\\n### OAS Generator\\nWe know that OAS is json/yaml document of API. Then, what is the OAS Generator?\\n\\n- OAS Generator is tool that generate Source code using OAS yaml file.\\n- In other words, It translates to this flow. API Swagger \u2192 OAS text file(.yaml) \u2192 Source Code(.ts).\\n- You can generate various output(Java, Kotlin, Typescript, etc.) using various Generator.\\n- In Web Front end ecosystem, I understand that [typescript-axios](https://openapi-generator.tech/docs/generators/typescript-axios) or [typescript-fetch](https://openapi-generator.tech/docs/generators/typescript-fetch) is mainly used.\\n\\nAs will be described later, OAS results are automatically generated in the following ways and benefit from using these codes inside the project.([code sandbox](https://codesandbox.io/s/oas-generator-sample-bygm5?file=/src/generate/api.ts:6692-6811))\\n```tsx\\n// Auto generated codes\\n...\\ndeletePet: async (petId: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\\n    // verify required parameter \'petId\' is not null or undefined\\n    assertParamExists(\'deletePet\', \'petId\', petId)\\n    const localVarPath = `/pet/{petId}`\\n        .replace(`{${\\"petId\\"}}`, encodeURIComponent(String(petId)));\\n    // use dummy base URL string because the URL constructor only accepts absolute URLs.\\n    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\\n    let baseOptions;\\n    if (configuration) {\\n        baseOptions = configuration.baseOptions;\\n    }\\n\\n    const localVarRequestOptions = { method: \'DELETE\', ...baseOptions, ...options};\\n    const localVarHeaderParameter = {} as any;\\n    const localVarQueryParameter = {} as any;\\n\\n    // authentication petstore_auth required\\n    // oauth required\\n    await setOAuthToObject(localVarHeaderParameter, \\"petstore_auth\\", [\\"write:pets\\", \\"read:pets\\"], configuration)\\n\\n    if (apiKey !== undefined && apiKey !== null) {\\n        localVarHeaderParameter[\'api_key\'] = String(apiKey);\\n    }\\n\\n\\n\\n    setSearchParams(localVarUrlObj, localVarQueryParameter);\\n    let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\\n    localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\\n\\n    return {\\n        url: toPathString(localVarUrlObj),\\n        options: localVarRequestOptions,\\n    };\\n},\\n...\\n```\\nThe above example are part of generated code using OAS generator.\\nIt generates codes that are filled path, method, headers and are set request and response about each api.\\n\\n## So, what\'s good?\\n### The difference from conventional way\\n![compare-with-oas-process](/assets/oas-generator/compare-with-oas-process.png)\\n\\nWe link APIs while developing. If we don\'t use OAS generator, We will develop following above AS-IS flow.\\nWe see API documents and check URL and method, etc and define the type of Request and Response.\\nThen, we create functions associated with axios and use API call logics.\\nIn this sequence, we can mistake to check the method incorrectly or can mistype during move the Request/Response type one by one.\\nIn addition, if API documents are updated, efforts are needed to recognize that the API has been updated and to follow the changes and modify them.\\n\\nOn the other hand, If we use OAS generator, we will develop following above TO-BE flow.\\nFirst, we bring yaml file(OAS spec) in the API docs. Generally yaml file is auto generated with API docs.\\nNext, we generate Axios functions using yaml file. The type of request and response are also generated same time.\\nIt is used for API call logic as it is.\\n\\nEven if API document is updated, running the OAS generator again shows the difference from the previous API as git diff,\\nand it is easy to see which part has changed and which part needs to be checked.\\n\\nIn other words, the advantage is to reduce repetitive work and minimize human errors by reducing the parts that developers write themselves.\\n\\n### It is just good?\\nI talked about advantages, but of course, there are points~~(disadvantages)~~ to pay attention to.\\n\\n#### 1. Yaml files should be able to be extracted from API documents.\\n\\nI think there are many ways to manage API documents by company and project.\\nThe example above is based on the premise of using a swagger.\\nIn various other ways, API documents may be shared or development may be carried out without API documents.\\nIf API documents are impossible to generate a yaml file, the OAS generate may not be a valid alternative\\n\\n#### 2. API documents must be accurate.\\n\\nSince the OAS Generator generates code based on API documents,\\nthe auto-generated code becomes inaccurate if the API documents are not accurate.\\nFor examples, If fields of request parameter are all set optional, all auto generated type are set optional.\\nThen, we can lose advantage of type check because optional is overused.\\nIn addition, if the actual serve has been updated but the API document has not been updated, the OAS generator rather complicates the project.\\nAPI documents should be as accurate as generating code through API documents.\\n\\n#### 3. Duplicated code, The increase bundle size.\\n\\nOAS Generator generate code using template and API documents.\\nTherefore, a specific pattern of template is repeated, which naturally creates duplicated code.\\nThis leads to a definite increase in bundle size.\\nEven if project development becomes easier and maintenance improves, it will inevitably be reluctant to use it if it adversely affects performance.\\nAt the env of this article, we will discuss optimization later, but it is necessary to compare bundle sizes before and after applying OAS Generator.\\n\\n#### 4. Initial configuration code and configuration maintenance\\n\\nWhat I felt when I applied the OAS Generator was that the initial configuration value was complicated and\\nthe learning curve was higher than I expected, and I customized several settings and templates for the project.\\nThe fact that there is a customization part means that there are more things to know about future project maintenances,\\nso several steps are needed, such as documentation or sufficient sharing within the team.\\n\\nIn particular, as described in No. 3, if optimization was conducted for project performance,\\nit would be necessary to share the history of this.\\n\\n### Next\\nSo far, I think we have outlined the advantages and disadvantages of using the OAS Generator.\\nNow, let\'s take some time to figure out hot to use it.\\n\\n## Usage of OAS Generator\\nThe introduction was long. Now I will explain how to use the OAS Generator.\\nExcept for Custom Template, most of the uses are to modify settings using the CLI.\\n\\nIn the [code sandbox](https://codesandbox.io/s/oas-generator-sample-bygm5), You can check the code shown in the example below.\\n### 1. Get the `yaml` file.\\nOAS Generator is a way of automatically generating code using a local yaml file.\\nIn addition, since it is 1:1 correspondence, one code is generated from one yaml file.\\nIf the API document has multiple yaml files, the flow described now must be executed several times.\\n\\n![usage-1](/assets/oas-generator/usage-1.png)\\nIn this example, I get the `petstore.yaml` file.\\n\\n### 2. generate code using `open-api-generator-cli`.\\nUsing open-api-generator-cli, specify template, input, and ouput path to generate code.\\n```shell\\nnpm install @openapitools/openapi-generator-cli\\nopenapi-generator-cli generate -g typescript-axios -i ./src/yaml/petstore.yaml -o ./src/generate\\n```\\nLike above, add dependency of [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli)\\nand run `openapi-generator-cli`\\n- `-g` is the option to set generator, in this case I used `typescript-axios`.\\n- `-i` means input. Set yaml file path used generate.\\n- `-o` is output path. Set where the code will be generated.\\n\\nIf you run above code, code is generated in the `src/generated` directory.\\n![usage-2.png](/assets/oas-generator/usage-2.png)\\n\\nInside `api.ts`, an axios util function containing the api request and response types and the type are generated together.\\n\\n### 3. Use generated code.\\nNow, you can use the generated code.\\n![usage-3.png](/assets/oas-generator/usage-3.png)\\n\\nSince it is a code generated based on the typescript, the type check of request and response proceeds successfully.\\nWhen referring to the `data` object, it informs the internal type of `Pet`, id , name, category, etc.\\n\\n### Next\\nA brief summary of how to use it is as follows.\\n> Get the `yaml` file -> Run OAS generator cli -> Use generated code\\n\\nHowever, as with all tools, it is necessary to customize it for real projects.\\nIn the [official documents](https://openapi-generator.tech/docs/customization), it serves several customize guides.\\nWhat I used was customizing the template.\\nThe customization method to be described in the article is mainly about how to customize the template.\\n\\n## OAS Generator Config\\n\\nThere are also some OAS generator settings.\\nMainly [CLI options](https://openapi-generator.tech/docs/usage#generate) and\\n[openapitools.json](https://openapi-generator.tech/docs/generators/typescript-axios) is set.\\n\\n### The setting of OAS Generator - CLI\\n![generator-cli-config.png](/assets/oas-generator/generator-cli-config.png)\\n- `-g`: The option to set `generator`. In this case, use `typescript-axios`.\\n- `-i`: The target yaml file path.\\n- `-o`: The generated output file path.\\n- `-c`: The setting file of generator.\\n- `-t`: **The custom template file path**\\n\\nThe CLI use the `generate` command,and there are five main options.\\nThe `-t` option is used to designate custom templates and will be discussed in following articles.\\n\\n### The setting of OAS Generator - Config file\\n```json\\n{\\n  \\"$schema\\": \\"node_modules/@openapitools/openapi-generator-cli/config.schema.json\\",\\n  \\"spaces\\": 2,\\n  \\"generator-cli\\": {\\n    \\"version\\": \\"5.3.1\\"\\n  },\\n  \\"supportsES6\\": true,\\n  \\"withSeparateModelsAndApi\\": true,\\n  \\"apiPackage\\": \\"api\\",\\n  \\"modelPackage\\": \\"models\\",\\n  \\"enumPropertyNaming\\": \\"original\\",\\n  \\"enumNameSuffix\\": \\"\\",\\n  \\"useSingleRequestParameter\\": false\\n}\\n```\\nThis configuration file is a file that enters `-c` in the CLI option, and mainly contains the generator configuration values.\\nIn this example, we use `typescript-axios` and see [here](https://openapi-generator.tech/docs/generators/typescript-axios/) for more options\\n\\n## OAS Generator Template\\nIt would be good to use the default settings, but you should need to edit setting for fitting actual project.\\nOfficial documents has [customization guide part](https://openapi-generator.tech/docs/customization).\\n[Retrieving Templates](https://openapi-generator.tech/docs/templating#retrieving-templates) was the most directly helpful item.\\nIn other words, the template registered by default is imported and modified according to the project.\\nThe way following this article is largely related to the template entering the `-t` option described in the CLI.\\n\\n### When do you use Custom Template?\\nThis is method to use when you want to modifiy and use a template that uses the default setting.\\nFor example, if you want to add a suffix such as `Axios` after the `addPet` or `deletePet` method names as follows,\\nyou can modify the template.\\n\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n<Tabs>\\n  <TabItem value=\'before\' label=\'Before using custom template\'>\\n\\n  ```tsx\\n  export class PetApi extends BaseAPI {\\n    public addPet(body: Pet, options?: AxiosRequestConfig) {\\n      return PetApiFp(this.configuration).addPet(body, options).then((request) => request(this.axios, this.basePath));\\n    }\\n\\n    public deletePet(petId: number, apiKey?: string, options?: AxiosRequestConfig) {\\n      return PetApiFp(this.configuration).deletePet(petId, apiKey, options).then((request) => request(this.axios, this.basePath));\\n    }\\n    ...\\n  }\\n  ```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After using custom template\'>\\n\\n  ```tsx\\n  export class PetApi extends BaseAPI {\\n    // highlight-next-line\\n    public addPetAxios(body: Pet, options?: AxiosRequestConfig) {\\n      return PetApiFp(this.configuration).addPet(body, options).then((request) => request(this.axios, this.basePath));\\n    }\\n\\n    // highlight-next-line\\n    public deletePetAxios(petId: number, apiKey?: string, options?: AxiosRequestConfig) {\\n      return PetApiFp(this.configuration).deletePet(petId, apiKey, options).then((request) => request(this.axios, this.basePath));\\n    }\\n    ...\\n  }\\n  ```\\n\\n  </TabItem>\\n</Tabs>\\n\\nOf course, it is only a simple examples, and it is possible to add parameters or customize other function.\\n\\n### Flow of Custom Template\\n\\n![generate-flow.png](/assets/oas-generator/generate-flow.png)\\nThe previous flow is the flow that generated the Axios function in the yaml file as above.\\nIf you add a Custom Template here, the flow changes as follows.\\n\\n![generate-flow-with-custom.png](/assets/oas-generator/generate-flow-with-custom.png)\\nThe OAS Generator extracts JSON data from the yaml file.\\nThis JSON data contains a path, a method, and various information about the API.\\nThese JSON data are injected into the Template and generated as an Axios function.\\n\\nThe custom to be following here is about hot to change the template.\\n\\n### Get the Template files\\n```shell\\nopenapi-generator-cli author template -g typescript-axios -o ./mustaches\\n```\\n`openapi-generator` has `author` scripts except `generate` script. <br/>\\nWhen `author` script is run, the following template is created.\\n```markdown\\n/mustaches\\n\u3134 api.mustache\\n\u3134 apiinner.mustache\\n\u3134 baseApi.mustache\\n\u3134 common.mustache\\n\u3134 configuration.mustache\\n  ...\\n```\\n\\nThis is a mustache template used to run OAS Generator with `typescript-axios`.\\nIf you don\'t give the `-t` option in the CLI, by default, use the corresponding mustache template located remotely to generate proceed.\\n\\nIn other word, if you modify only the mustache template that you want to modify and delete the remaining unmodified templates,\\nyou can reduce the management area by following the remote default settings.\\n\\n### Mustache Template\\nWe can now modify mustache imported to local.\\nThis requires a brief understanding of mustache grammar, so if you are not familiar with mustache, check [this article](https://github.com/janl/mustache.js).\\nAs alone as you can only read variables, Sections, Lists, and Inverted Sections, since you are modifying an already completed template.\\n\\nFor example, if you want to attache a suffix called Axios to the classname created as [the example introduced above](#when-do-you-use-custom-template),\\nyou can modify it as follows.\\n\\n<Tabs>\\n  <TabItem value=\'before\' label=\'Before Custom Template\'>\\n\\n```tsx title=apiInner.mustache\\n{{^useSingleRequestParameter}}\\n  public {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: AxiosRequestConfig) {\\n  return {{classname}}Fp(this.configuration).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options).then((request) => request(this.axios, this.basePath));\\n}\\n{{/useSingleRequestParameter}}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Custom Template\'>\\n\\n```tsx title=apiInner.mustache\\n{{^useSingleRequestParameter}}\\n  // highlight-next-line\\n  public {{nickname}}Axios({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: AxiosRequestConfig) {\\n  return {{classname}}Fp(this.configuration).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options).then((request) => request(this.axios, this.basePath));\\n}\\n{{/useSingleRequestParameter}}\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n![simple-mustache-custom.png](/assets/oas-generator/custom-template-file-structure.png)\\n\\nThen, leave only the modified template file and delete the remaining unmodified template files.\\nFiles that are not locally generated are automatically generated using remote templates.\\n\\n### Check JSON Data\\nNow, I have imported the template locally, and I know that I can modify the template.\\nHowever, the question still arises is that you do not know what value is included in the variable `nickname` or `classname` in the template image above.\\n\\nNow, it\'s time to check out the JSON Data, which went over from [Flow of Custom Template](#flow-of-custom-template).\\n\\nTo use appropriate data for the template, you need to find out what data is extracted from the yaml file and in what format it is injected into the template.\\n```shell\\nopenapi-generator-cli generate  \\\\ \\n  -g typescript-axios  \\\\\\n  -i ./src/yaml/petstore.yaml  \\\\\\n  -o ./src/generate  \\\\\\n  --global-property=debugModels,debugOperations \\\\\\n  > output.txt\\n```\\nThere are many ways to do this, but if you give the CLI option `--global-property=debugModels,debugOperations`,\\nWhat data is extracted from the yaml file is output to the console. Therefore, a method of checking with a text file through `> output.txt` was used.\\n\\nThe extracted contents of `operations` follow the image format as shown below, and `operators` that can be seen in the template,\\nIt can be seen that data such as `classnames`, `path`, and `httpMethod` are included and used in the mustache template.\\n![json-data.png](/assets/oas-generator/json-data.png)\\n\\n## The example of Custom Template\\nAs an example of using a Custom Template, I brought up the use of \\"axios\\" in the suffix.\\nHowever, it is only a simple example to help understanding, and it can be applied in various ways in actual use.\\nI brought the custom example used in the actual project.\\n\\nSince we can\'t see the entire code and following example is part of generated code,\\nit may not be clearly understood how it is implemented.\\nHowever, I hope you can see the following examples as a possibility and get the idea of using Custom Template.\\n\\n### Convert from Enum Type to Union Type\\n\\n`typescript-axios` template is using `Enum` type of typescript when define type. But I don\'t like to use `Enum` type.\\nSo, I tried to convert to `Union` type.\\n\\n<Tabs groupId=\\"enum-to-union\\">\\n  <TabItem value=\'before\' label=\'Before Custom Template\'>\\n\\n```tsx title=modelGeneric.mustache\\n{{#vars}}\\n{{#isEnum}}\\n  export enum {{enumName}} {\\n{{#allowableValues}}\\n{{#enumVars}}\\n{{{name}}} = {{{value}}}{{^-last}},{{/-last}}\\n{{/enumVars}}\\n{{/allowableValues}}\\n}\\n{{/isEnum}}\\n{{/vars}}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Custom Template\'>\\n\\n```tsx title=modelGeneric.mustache\\n{{#vars}}\\n{{#isEnum}}\\n  export type {{enumName}} =\\n{{#allowableValues}}\\n{{#enumVars}}\\n{{{value}}} {{^-last}}|{{/-last}}\\n{{/enumVars}}\\n{{/allowableValues}}\\n{{/isEnum}}\\n{{/vars}}\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n\\n<Tabs groupId=\\"enum-to-union\\">\\n  <TabItem value=\'before\' label=\'Before Generated Code\'>\\n\\n```tsx\\nexport enum PetStatusEnum {\\n  Available = \'available\',\\n  Pending = \'pending\',\\n  Sold = \'sold\',\\n}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Generated Code\'>\\n\\n```tsx\\nexport type PetStatusEnum =\\n  \'available\' |\\n  \'pending\' |\\n  \'sold\'\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n### Convert to Snake case variable naming rule to Camel case variable naming rule\\nThe server used the snake case for the variable naming rule, and the client used the camel case as the variable naming rule.\\nTherefore, there were difficulties caused by different variable names used in the OAS document and the actual generated code.\\nUse the [lambdas](https://openapi-generator.tech/docs/templating/#mustache-lambdas) provided by the OAS generator.\\nSnake case naming variables were collectively converted into camel case naming variables.\\n\\n<Tabs groupId=\\"snake-to-camel\\">\\n  <TabItem value=\'before\' label=\'Before Custom Template\'>\\n\\n  ```tsx title=modelGeneric.mustache\\n    {{#vars}}\\n      \'{{baseName}}\'{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};\\n    {{/vars}}\\n  ```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Custom Template\'>\\n\\n  ```tsx title=modelGeneric.mustache\\n    {{#vars}}\\n      // highlight-next-line\\n      \'{{#lambda.camelcase}}{{baseName}}{{/lambda.camelcase}}\'{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};\\n    {{/vars}}\\n  ```\\n\\n  </TabItem>\\n</Tabs>\\n\\n\\n<Tabs groupId=\\"snake-to-camel\\">\\n  <TabItem value=\'before\' label=\'Before Generated Code\'>\\n\\n```tsx\\nexport interface User {\\n  id: number;\\n  username: string;\\n  first_name: string;\\n  last_name: string;\\n  email: string;\\n  password: string;\\n  phone: string;\\n  user_status: number;\\n}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Generated Code\'>\\n\\n```tsx\\nexport interface User {\\n  id: number;\\n  username: string;\\n  // highlight-next-line\\n  firstName: string;\\n  // highlight-next-line\\n  lastName: string;\\n  email: string;\\n  password: string;\\n  phone: string;\\n  // highlight-next-line\\n  userStatus: number;\\n}\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n### Edit util function in template\\n\\nI extracted the utility function that commonly used logic in `typescript-axios` and generate code.\\nFor example, serialize did not need to be used in our project, and `serialize` logic was excluded by modifying it as follows.\\n\\n<Tabs groupId=\\"custom-util-func\\">\\n  <TabItem value=\'before\' label=\'Before Custom Template\'>\\n\\n```tsx title=common.mustache\\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\\n  const nonString = typeof value !== \'string\';\\n  const needsSerialization = nonString && configuration && configuration.isJsonMime\\n    ? configuration.isJsonMime(requestOptions.headers[\'Content-Type\'])\\n    : nonString;\\n  return needsSerialization\\n    ? JSON.stringify(value !== undefined ? value : {})\\n    : (value || \\"\\");\\n}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Custom Template\'>\\n\\n```tsx title=modelGeneric.mustache\\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\\n  const nonString = typeof value !== \'string\';\\n  // highlight-next-line\\n  const needsSerialization = false;\\n  return needsSerialization\\n    ? JSON.stringify(value !== undefined ? value : {})\\n    : (value || \\"\\");\\n}\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n\\n<Tabs groupId=\\"custom-util-func\\">\\n  <TabItem value=\'before\' label=\'Before Generated Code\'>\\n\\n```tsx\\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\\n  const nonString = typeof value !== \'string\';\\n  const needsSerialization = nonString && configuration && configuration.isJsonMime\\n    ? configuration.isJsonMime(requestOptions.headers[\'Content-Type\'])\\n    : nonString;\\n  return needsSerialization\\n    ? JSON.stringify(value !== undefined ? value : {})\\n    : (value || \\"\\");\\n}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Generated Code\'>\\n\\n```tsx\\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\\n  const nonString = typeof value !== \'string\';\\n  // highlight-next-line\\n  const needsSerialization = false;\\n  return needsSerialization\\n    ? JSON.stringify(value !== undefined ? value : {})\\n    : (value || \\"\\");\\n}\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n## The story of optimization\\n\\nWe understand pros and cons of OAS Generator, and we know that usage and method to customize.\\nIf so, the essential story is optimization.\\nA good tool has been applied, and it reduces hassle and improves development stability,\\nbut it can\'t be easily use if it adversely effects performance.\\n\\nOAS Generator is largely influenced by bundle size. When using the OAS Generator, the amount of code increases,\\nwhich leads to an increase in bundle size.\\nThen user sees the web page late. Therefore, it must be checked.\\n\\nWhen I applied it to the project, there were about 10 yarm files in the project, and each yaml file had a single feature.\\nAs this was gradually applied one by one for each function, the generated code had the following capacity.\\n\\n![bundle-size-before](/assets/oas-generator/bundle-size-before.png)\\n\\nWhen one feature was applied, the generated code had a size of 20KB based on gzip, and 63KB when two features were applied.\\nConsidering that the total gzip size of the project at that time was around 560KB,\\nit was a fatal condition that increased the capacity by 11% of the total.\\nEven since it was not applied to all features, it could be expected that the size would increase arithmetically in the future.\\n\\n### Attempt 1: Reduce total code size.\\nThe first attempt is to reduce the amount of code. generate, due to the nature of automatic code generation,\\na single line of templates influenced dozens of generated codes.\\nThis led to an increase in the overall code volume, bundle size.\\nTherefore, the required variable\'s guard logic and the header settings that are not used in our project were removed.\\nIn addition, for the same common code repeatedly generated by the OAS Generator,\\nmethods such as moving it inside the project and using it as a common function were used.\\n\\n![bundle-size-solution-1](/assets/oas-generator/bundle-size-solution-1.png)\\n\\nThis solution reduced the size from 63KB to 34KB to about 53%. The code that you don\'t use for each project is different,\\nso the degree of reduction is different. Please note that removing unnecessary logic from the template was also effective in reducing the bundle size.\\n\\n### Attempt 2: Tree shaking\\nThe amount of code has been reduced enough. However, there was still a way to further reduce the bundle size.\\nIt\'s tree shaking.\\n\\nIf you use all the APIs in the API document, you don\'t have to consider tree shaking, but our project didn\'t\\nTherefore, if unused API codes are included in the bundle, it means that unnecessary codes are included, which can be seen as an improvement.\\n\\nThis may vary depending on the bundler and usage environment, but the project I experienced was building using webpack v5,\\nand webpack v5 was using variable units instead of file units about tree shaking, so I thought tree shaking was working well, but it wasn\'t.\\nThis is because APIs were not created with each variable, but were created in the form of a method under one object, class.\\n\\nIn webpack v5, each variable supports tree shaking, and the unused variable is excluded from the bundle,\\nbut the key / value present in the object is not.\\n\\nTherefore, it was changed from a structure in which all API call functions were contained in one existing object\\nto a structure in which each API call function was separated into each variable.\\n\\nThis change was also carried out by customizing the template.\\n\\n<Tabs>\\n  <TabItem value=\'before\' label=\'Before Generated Code\'>\\n\\n```tsx\\nexport const PetStoreApi {\\n  getPet: () => { ... },\\n  postPet: () => { ... },\\n}\\n```\\n\\n  </TabItem>\\n  <TabItem value=\'after\' label=\'After Generated Code\'>\\n\\n```tsx\\nexport const petStoreGetPet = () => { ... }\\nexport const petStorePostPet = () => { ... }\\n```\\n\\n  </TabItem>\\n</Tabs>\\n\\n![bundle-size-tree-shaking](/assets/oas-generator/bundle-size-tree-shaking.png)\\n\\nAfter the tree shaking, the size decreased from 34KB to 25KB.\\nAlthough it has not improved significantly in terms of ratio,\\nit was possible to guarantee that only the necessary codes were included in future implementations.\\n\\n### Result\\nThe bundle-size optimization caused by OAS ends here.\\nIf you look at the final result, the OAS generated code takes up 25KB, which seems to be quite a lot.\\nComparing the entire project bundle-size was as follows.\\n![bundle-size-total](/assets/oas-generator/bundle-size-total.png)\\n\\nWhen OAS was not applied at all, the project, which was about 567KB, showed a slight increase of about 572KB after OAS was applied.\\nTherefore, it was concluded that even if OAS is applied, size is not a big problem if appropriate optimization and analysis processes are performed.\\n\\n## Recap\\n- The OAS Generator is a tool for converting API documents into development code(.ts).\\n- This reduces human errors and reduces resources to work manually, such as creating types.\\n- Code is auto generated like this flow. `yaml file -> oas-generator-cli -> generated code`.\\n- The OAS Generator can customize and use the code template for the project.\\n- If you don\'t optimize the OAS generator, It can cause a lot of lose to the bundle size, but if you do so, you won\'t have to worry."},{"id":"deep-dive-to-immer","metadata":{"permalink":"/en/deep-dive-to-immer","source":"@site/i18n/en/docusaurus-plugin-content-blog/2021-10-23-deep-dive-to-immer.md","title":"Deep dive to immer","description":"immer, usually used by redux, help us to update mutable object like using immutably. How can it do this? Lets deep dive to immer.","date":"2021-10-23T00:00:00.000Z","formattedDate":"October 23, 2021","tags":[{"label":"redux","permalink":"/en/tags/redux"},{"label":"redux-toolkit","permalink":"/en/tags/redux-toolkit"},{"label":"immer","permalink":"/en/tags/immer"},{"label":"library","permalink":"/en/tags/library"},{"label":"how-to-work","permalink":"/en/tags/how-to-work"},{"label":"deep-dive","permalink":"/en/tags/deep-dive"},{"label":"javascript","permalink":"/en/tags/javascript"},{"label":"web","permalink":"/en/tags/web"},{"label":"immutable","permalink":"/en/tags/immutable"}],"readingTime":26.85,"truncated":true,"authors":[{"name":"Hyunmo Ahn","title":"Front End Engineer @ Line Financial+","url":"https://github.com/HyunmoAhn","imageURL":"https://github.com/HyunmoAhn.png","key":"HyunmoAhn"}],"frontMatter":{"slug":"deep-dive-to-immer","title":"Deep dive to immer","description":"immer, usually used by redux, help us to update mutable object like using immutably. How can it do this? Lets deep dive to immer.","keywords":["redux","redux-toolkit","immer","immutable","javascript","deep-dive","how-to-work","web"],"authors":"HyunmoAhn","tags":["redux","redux-toolkit","immer","library","how-to-work","deep-dive","javascript","web","immutable"]},"prevItem":{"title":"How to use OAS generator in Front-end environment?","permalink":"/en/how-to-use-oas-generator"},"nextItem":{"title":"how to time travel debugging at redux-devtools","permalink":"/en/how-to-time-travel-debugging-at-redux-devtools"}},"content":"This article basically takes time to learn about immer [immer](https://immerjs.github.io/immer/).\\nIf you don\'t know immer, I recommend reading [next chapter](#what-is-immer-and-why) first.\\n\\n## What is my curious?\\n\\n:::tip Question\\nQ1. How does `immer` change the mutable update way to immutable update way?\\n:::\\n`immer` functions to return data immutably even when using the object built-in method that changes to be mutable.\\nLet\'s find out how this function works internally.\\n\\nThis example is following basic example of [immer official docs](https://immerjs.github.io/immer/#a-quick-example-for-comparison)\\n```tsx\\nimport produce from \'immer\';\\n\\nconst baseState = [\\n  { \\n    title: \\"Learn TypeScript\\", \\n    done: true,\\n  },\\n  { \\n    title: \\"Try Immer\\", \\n    done: false,\\n  },\\n]\\n\\nconst nextState = produce(baseState, (draft) => {\\n  draft.push({ title: \\"Tweet about It\\" });\\n  draft[1].done = true;\\n})\\n\\nconsole.log(baseState === nextState) // false\\nconsole.log(nextState)\\n/*\\n[\\n  { \\n    title: \\"Learn TypeScript\\", \\n    done: true,\\n  },\\n  { \\n    title: \\"Learn TypeScript\\", \\n    done: true,\\n  },\\n  { \\n    title: \\"Tweet about It\\",\\n  },\\n]\\n*/\\n```\\n\\n:::tip Question\\nQ2. How does `immer` use `structural sharing`?\\n\\n*`structural sharing`: When coping an object, the same reference is used for an object that has not been changed.\\n:::\\nTo update object immutably means that original object is copied to new object. In other word, copy needs to cost. \\nWhen `immer` copy object, the unchanged reference copies the object using the structural sharing method that is reused.\\nLet\'s find out what kind of structural sharing is used in `immer`.\\n\\n:::tip Question\\nQ3. `immer` sometimes updates data through return rather than mutable updating the draft within `produce` function,\\nin which case the logic is different?\\n:::\\n\\nWhen using an `immer`, there is a case of returning a new object instead of the mutable update method suggested above. \\nThis is same as the method of returning objects from javascript immutably regardless of the immer.\\n`immer` [officially is guiding](https://immerjs.github.io/immer/return) this way and \\nThere will be many developers who use both methods, the method of changing objects to be mutable and method of changing objects to be immutable.\\nLet\'s see what logic differences these differences cause in the `immer`.\\n\\n```tsx\\n// mutable method\\nconst nextState = produce(baseState, (draft) => {\\n  draft.push({ title: \\"Tweet about It\\" });\\n  draft[1].done = true;\\n})\\n\\n// highlight-start\\n// immutable method\\nconst nextState = produce(baseState, (draft) => {\\n  return {\\n    ...baseState,\\n    { ...baseState[1], done: true },\\n    { title: \\"Tweet about It\\" },\\n  }\\n})\\n// highlight-end\\n```\\n\\n\\n:::info PREREQUISITES\\n- Experience using an `immer` or `redux-toolkit`\\n- Understanding of [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) (optional)\\n:::\\n\\n\x3c!--truncate--\x3e\\n\\n## What is immer, and why?\\n\\n***If you know properly why we use `immer`, this can be boring. If you know, Let\'s [next chapter](#usage)***\\n\\nWhat is [immer](https://immerjs.github.io/immer/)? \\nLet\'s bring the introductory phrase from the official docs of `immer`.\\n\\n> `Immer` (German for: always) is a tiny package that allows you to work with immutable state in a more convenient way.\\n\\n`immer` is the library that ensures that data is immutably updated in javascript.\\n\\nThen, where is `immer` being used? <br/>\\nIn style guide of redux, [recommend to using redux-toolkit](https://ko.redux.js.org/style-guide/style-guide#use-redux-toolkit-for-writing-redux-logic) using redux \\nand [recommend to using immer](https://ko.redux.js.org/style-guide/style-guide#use-immer-for-writing-immutable-updates) for managing object immutability.\\nOf course, If you use [redux-toolkit](https://redux-toolkit.js.org/), you already are using immer because `redux-toolkit` is using `immer` internally\\n\\nIt is recommended to refer to the [FAQ of redux](https://ko.redux.js.org/style-guide/style-guide#use-immer-for-writing-immutable-updates) for why immutable data should be used. <br/>\\nTo briefly explain the content, it is as follows. <br/>\\njavascript \\n\\nThe variable except of primitive type like number, string etc. have mutable type in javascript.\\n`Non-primitive` types include objects and arrays.\\nEven if a non-primitive type of variable is changed, the reference of the variable does not change.\\nSo, If inner of object is changed, reference is not changed.\\n\\n```tsx\\nlet primitive = 5;\\nlet primitive2 = primitive;\\n\\nconsole.log(primitive === primitive2) // true\\nprimitive2 = 10;\\n\\nconsole.log(primitive === primitive2) // false\\n\\n\\nlet nonPrimitive = { a: 5 };\\nlet nonPrimitive2 = nonPrimitive;\\n\\nconsole.log(nonPrimitive === nonPrimitive2) // true\\n\\nnonPrimitive2.b = 10;\\n\\nconsole.log(nonPrimitive === nonPrimitive2) // true\\nconsole.log(nonPrimitive) \\n// { a: 5, b: 10 }  \\n```\\n[redux](https://redux-saga.js.org/) is using `shallow equality checking`.\\nWhen comparing whether the data is the same, `shallow equality checking` doesn\'t check whether the inside of the data has changed,\\nbut rather determines that the reference of the data has changed. If it is the same, it has not changed.\\n\\nIf using `deep eqaulity checking`, we suffer performance losses because all object have to be compared one by one.\\nSo, when we changed the object, we used immutable data that guarantees that the reference is also changed, \\nand we use `immer` because it guarantees that the object is immutable with any changes. \\n\\nEven if you have never consciously used an `immer`, if you are using a `redux-toolkit` to use `redux`, you are already using an `immer`.\\n\\n## Usage\\nBefore deep dive to immer, Let\'s show check to use `immer`.\\nNext is the example in [immer docs](https://immerjs.github.io/immer/#a-quick-example-for-comparison).\\n\\n- The compare way to update baseState immutably\\n```tsx\\nconst baseState = [\\n  {\\n    title: \\"Learn TypeScript\\",\\n    done: true\\n  },\\n  {\\n    title: \\"Try Immer\\",\\n    done: false\\n  }\\n]\\n```\\n```tsx\\n// without immer\\nconst nextState = baseState.slice()\\n\\nnextState[1] = { \\n  ...nextState[1], \\n  done: true, \\n}\\nnextState.push({ title: \'Tweet about it\' })\\n```\\n```tsx\\n// with immer\\nimport produce from \\"immer\\"\\n\\nconst nextState = produce(baseState, draft => {\\n    draft[1].done = true\\n    draft.push({ title: \\"Tweet about it\\" })\\n})\\n```\\nIf we don\'t use `immer`, we need to do copy \u2192 update process and need to check if object is changed mutably or not. \\nBut, if we use `produce` of `immer`, it can be ensured that data is immutable no matter how we use it.\\n\\nIf you have never been used an `immer` yourself and used the `redux` using the [redux-toolkit](https://redux-toolkit.js.org/),\\nyou are already using the `immer`.\\nIf you\'re not sure, [read this document](https://redux-toolkit.js.org/api/createReducer#direct-state-mutation) on how to mutate the state in the redux-toolkit\\n\\n## About immer before deep-dive \\nFirst, I will talk about the principle of `immer`.\\nThe contents described here will be easier to understand by referring to the article of the [document of immer](https://immerjs.github.io/immer/#how-immer-works)\\nand [the blog article](https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3#3bff) linked to the FAQ of documents. \\n\\n### immer doesn\'t update original data\\nWhen update data, `immer` doesn\'t update original data(`base_`). \\nBut it create copy data(`copy_`) using `base_` and update `copy_` instead of updating original data.\\nUsing this principle, the updated data is returned without changing the original data.\\n\\n### immer record if object is updated or not\\n`immer` set `modified_` flag to `true` when update object.\\nIf deep part of object tree is modified, `immer` update `modified_` flag from deep part to root tree. \\nThen `immer` can traverse root to lear tree. \\n\\nAfter completing the object update process, `immer` check the `modified_` flag. \\nIf object is modified, use copy data(`copy_`). \\nIf it is not modified, the structural share is used by reusing the existing reference using original data(`base_`).\\n\\n### Recap\\nIn short, It is summarized in three lines.\\n\\n- Manage two type of object, `original data` and `copy data`, preserve original data and update copy data only.\\n- The changed object can be traversed from the root tree to the leaf tree by turning on the modified flag.\\n- After the update is completed, the process of combining the new and existing objects using the modified flag is performed.\\n\\n\\n## Deep dive to immer\\nLet\'s deep dive to immer. <br/>\\nTo check logic of `immer`, we need to checking `produce` function used in usage first.\\n\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/immer.ts#L23-L45\\nconst immer = new Immer();\\nexport const produce = immer.produce;\\nexport default produce;\\n```\\n`produce` function is method function of `Immer` class. Let\'s see inner `Immer` class.\\n\\nExcluding the curring function handling and several exception cases in the `produce` function, it is reduced as follows.\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/immerClass.ts#L66-L122\\nexport class Immer {\\n  produce: (base, recipe) => { \\n    let result;\\n\\n    const scope = enterScope(this);\\n    const proxy = createProxy(this, base, undefined);\\n    \\n    result = recipe(proxy);\\n\\n    return processResult(result, scope);     \\n  }\\n}\\n```\\nSince the `produce` function is simpler than excepted, let\'s move on to the order of the `produce` function logic.\\n1. `produce` function receives parameters that existing object(`base`) and the function that determines how to update the object(`recipe`).\\n2. Create `scope`.\\n3. Create `proxy`.\\n4. Run `recipe` using `proxy`.\\n5. Return the final object updated using `processResult`.\\n\\nWhat should be questioned here is that the logic of mutable updating is included `recipe` and `recipe` function is just called only.\\nBut the logic of mutable updating inner `recipe` does immutable update without updating target object directly.\\n\\nThe secret may be `proxy`. In fact, when creating a proxy, it uses a [new Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy),\\nwhich acts as a key point for the main logic of the `immer`.\\n\\nLet\'s take a look one by one.\\n\\n### scope\\n`scope` is an object that stores information to be used throughout the immer. \\nIt is not used much in the basic logic of the `immer`.\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/scope.ts#L33-L46\\nfunction createScope(\\n  parent_: ImmerScope | undefined,\\n  immer_: Immer\\n): ImmerScope {\\n  return {\\n    drafts_: [],\\n    parent_,\\n    immer_,\\n    canAutoFreeze_: true,\\n    unfinalizedDrafts_: 0\\n  }\\n}   \\n```\\n`drafts_` is an array that is contained one by one when creating a `proxy` that is made later \\nand `immer_` is a space that contains an immer class.\\n\\n### proxy\\nLet\'s check `proxy`, which is the core of the `immer`.\\n\\n`immer` responds not only to objects but also to cases where Array, Map, Set and proxy can\'t be used(ES5), \\nso the code seems complicated, but if we look at it only with objects, logic becomes a little simpler.\\n\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/immerClass.ts#L212-L229\\nexport function createProxy(immer, value, parent) {\\n  const draft = createProxyProxy(value, parent);\\n  const scope = getCurrentScope();\\n  \\n  scope.drafts_.push(draft);\\n  return draft;\\n}\\n```\\nTo know how to create `proxy`, we need to check `createProxyProxy` function.\\nThe focus point here is that the generated proxy is put in `scope.drafts_`.\\nThe `proxy` first created is root proxy. So `immer` will use `scope.drafts_[0]` when get `rootProxy` later.\\n\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/proxy.ts#L50-L95\\nexport function createProxyProxy(base, parent) {\\n  const state = {\\n    ...\\n    scope_: getCurrentScope(),\\n    modified_: false,\\n    finalized_: false,\\n    parent_: parent,\\n    base_: base,\\n    draft_: null,\\n    copy_: null,\\n    ...\\n  }\\n\\n  const target = state;\\n  const traps = objectTraps\\n  const { revoke, proxy } = Proxy.revocable(target, traps);\\n  state.draft_ = proxy;\\n  state.revoke_ = revoke\\n  \\n  return proxy;\\n} \\n```\\nIn `createProxyProxy`, various metadata and new `Proxy` objects are created to be used for immer operation.\\nThe metadata used in the immer is summarized as follows.\\n- `base_`: Existing data. It came in as the first parameter in `produce` and the original data before it is changed is stored here.\\n- `copy_`: Updated data. Updated data is saved here using original data and `recipe`. It doesn\'t have any data yet.\\n- `draft_`: `draft_` save `Proxy` object that will create here. In the future logic, data is referred to in the same way as `draft_.base` or `draft_.copy`.\\n- `modified_`: It stores whether the object has been changed. Default value is `false` because object is not updated.\\n- `finalized_`: It stores whether the proxy complete to update and ready to be returned. Default value is `false` because the object is being prepared. \\n- `parent_`: Object can be multi depth. If object composed tree form, parent tree is saved here. This is empty in root proxy.\\n\\nThe main metadata is summarized above. \\nThe default value of metadata is set here and `Proxy` object is created by `Proxy.revocable` and `traps`.\\nLet\'s see about Proxy in next chapter. \\n\\n:::info Terms\\n### proxy? Proxy?\\nFrom now on, I will mention the variable `proxy` that includes the `new Proxy` object, including metadata,\\nand also will mention the object `Proxy` to control various basic actions against objects in javascript as the terms implies.\\nCoincidentally, since the two terms are the same term as \\"proxy\\", in this article, the two will be divided into \'p\' as follows. \\n- `proxy`: The object containing metadata generated by `immer` and `draft` generated by `new Proxy`.\\n- `Proxy`: built-in object served by javascript. It is used as an object to control various basic traps of an object.\\n:::\\n\\n### new Proxy\\n***In this chapter, we have a time to know what is the [new Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\\nIf you are familiar with `Proxy`, it doesn\'t matter if you [move on to the next chapter](#traps-of-immer)***\\n\\nWe created `Proxy` object using `Proxy.revocable` in previous chapter.\\n\\nThe definition of Proxy in [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) is following.\\n\\n> The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.\\n\\n`Proxy` object create new Object that intercept or redefine feature of object like set or get.\\n`Immer` uses `Proxy` to intercept logic to update the original object in a different way, rather than directly updating the object\\nwhen getting and setting the original object by creating a `Proxy` object with the original object.\\n\\nFor example, if you have an object and want to dobule the value you set when you set it, you can use it as follows.\\n\\n```tsx\\nconst origin = {};\\nconst handler = {\\n  set: function(target, prop, value) {\\n    if (typeof value === \'number\') {\\n      target[prop] = value * 2;\\n    } else {\\n      Reflect.set(...arguments);\\n    }\\n  }\\n}\\n\\nconst proxy = new Proxy(origin, handler);\\n\\nproxy.a = 10;\\nproxy.b = {};\\n\\nconsole.log(proxy.a); // 20\\nconsole.log(proxy.b); // {}\\n```\\nWhen assign to `proxy.a`, the normal set of objects is not used, but the logic of `handle.set` registered when creating the `Proxy` object is used. \\nBecause the value to set is 10, `proxy.a` is saved 20 not 10.\\n`Reflect`, which is used in the operation when the value is not the number, is used to follow the existing logic. \\n\\nNow, what if an additional value is allocated to the object `proxy.b`?\\nWill 40 be assigned? Or will 20 be assigned?\\n```tsx\\nproxy.b.c = 20\\n\\nconsole.log(proxy.b.c) // 20? 40?\\n```\\nThe answer is 20. The reason is that `proxy` is a Proxy object, but `proxy.b` is not a Proxy object but a plain object.\\nTherefore, 20 is allocated as it is using a set of plain object without using `handle.set`.\\n\\nThis action acts critically in the `immer`.\\nThis is because there will be many cases in which child objects \\nthat become several depth are immediately changed in the process of updating the object. \\n\\nTherefore, it responds in the following ways.\\n```tsx\\nconst origin = {};\\nconst handler = {\\n  set: function(target, prop, value) {\\n    if (typeof value === \'number\') {\\n      target[prop] = value * 2;\\n    } else {\\n      Reflect.set(...arguments);\\n    }\\n  },\\n  // highlight-start\\n  get: function(target, prop) {\\n    if (typeof target[prop] === \'object\') {\\n      return new Proxy(target[prop], handler);\\n    }\\n    \\n    return Reflect.get(...arguments);\\n  }\\n  // highlight-end\\n}\\n\\nconst proxy = new Proxy(origin, handler);\\n\\nproxy.b = {};\\nproxy.b.c = {};\\nproxy.b.c.d = 20;\\n\\nconsole.log(proxy.b.c); // Proxy {}\\nconsole.log(proxy.b.c.d); // 40\\n```\\nWhen create Proxy, we add custom logic not only get but also set. \\nWhen getting a value from a Proxy object, if it is normal object, it create and get a proxy object. \\nIn this case, the Proxy object is also a Proxy object, and `proxy.b` also returns the Proxy object, not the general object, using `handler.get`.\\nTherefore, if 20 is assigned to `proxy.b.c`, 40 is allocated in `proxy.b.c` not 20 because `proxy.b` is Proxy object. \\n\\nUsing these actions of get and set, `Immer` uses logic using `base_` and `copy_` without directly updating the object \\nin the set so that even when referring to deep objects in get, Proxy can be referenced.\\nLet\'s find out how it is implemented in the next chapter.\\n\\n:::tip About `latest` and `peek`\\nFrom now on, we may be meet a lot about `latest` and `peek`, which are the util functions used in the `immer` code.\\nIf you\'re curious about what this function does, let\'s take a look.\\n- latest\\n```tsx\\n// https://github.com/immerjs/immer/blob/master/src/utils/common.ts#L160-L162\\nexport function latest(state) {\\n  return state.copy_ || state.base_\\n}\\n```\\n`state` is proxy object created in `produce`. proxy object has metadata and object that is created by `new Proxy`. \\n`latest` brings in a `copy_` or `base_` object, and it can be seen that it is currently used to bring data held by proxy.\\n`copy_` is the latest object updated and `base_` is original object so the priority is to bring `copy_` first.\\n\\n- peek\\n```tsx\\n// https://github.com/immerjs/immer/blob/master/src/core/proxy.ts#L234-L238\\nexport function peek(draft, prop) {\\n  const state = draft[DRAFT_STATE];\\n  const source = state ? latest(state) : draft;\\n  return source[prop]\\n}\\n```\\n`peek` has role to bring value of specific key in object. In other word, It is used to bring key matched prop in draft.\\nThere are three cases here.\\n1. When draft is plain object not Proxy object.\\n    - In this case, It return immediately with reference to `draft[prop]` because `draft[DRAFT_STATE]` is `undefined`.\\n2. When draft is Proxy object and has `copy_`\\n   - Returns `copy_.[prop]`.\\n3. When draft is PRoxy object and doesn\'t have `copy_`\\n    - Returns `base_.[prop]`.\\n\\nIn other word, it is util function to get value to match key from object(or proxy) for several case.  \\n:::\\n\\n### Traps of immer\\nimmer\uc758 `Proxy`\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 get\uc740 multi depth\uc758 \uac1d\uccb4\ub97c \ucc38\uc870\ud588\uc744\ub54c\uc5d0\ub3c4 Proxy\ub97c \ucc38\uc870\ud560 \uc218 \uc788\uac8c Proxy\ub97c \uc0dd\uc131\ud574\uc8fc\ub294 \uc5ed\ud560\uc744 \uac00\uc9c0\uace0 \uc788\uace0,\\nset\uc740 \uc6d0\ubcf8 \uac1d\uccb4\ub97c \ubcc0\uacbd\ud558\ub824 \ud560 \ub54c \uc774\ub97c \ub9c9\uace0 `base_`, `copy_`, `modified_`\uc640 \uac19\uc740 \uba54\ud0c0 \ub370\uc774\ud130\ub97c \uc81c\uc5b4\ud558\ub3c4\ub85d \ud558\ub294 \uc5ed\ud560\uc744 \uac00\uc9c0\uace0 \uc788\ub2e4.\\n\\n#### Get\\nThe purpose of logic of get is that create proxy object to use it even if we access deep tree directly. \\n```tsx\\n// https://github.com/immerjs/immer/blob/master/src/core/proxy.ts#L101-L124\\nexport const objecTraps = {\\n  get(state, prop) {\\n    if (prop === DRAFT_STATE) return state;\\n\\n    const source = latest(state);\\n    const value = source[props];\\n    \\n    if (state.finalized_ || !isDraftable(value)) return value    \\n\\n    if (value === peek(state.base_, prop)) {\\n      prepareCopy(state);\\n      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state)\\n    }\\n    \\n    return value\\n  }\\n}\\n```\\n\\n```tsx\\nif (prop === DRAFT_STATE) return state;\\n```\\n\\nThis first `DRAFT_STATE` condition logic seems hole logic to get draft from `immer` immediately. \\nWe can check that it brings proxy by calling `draft[DRAFT_STATE]` in utils function like `peek`.\\n\\n```tsx\\nconst source = latest(state);\\nconst value = source[prop];\\n    \\nif (state.finalized_ || !isDraftable(value)) return value  \\n```\\nNext logic is condition when we don\'t need to create proxy object.\\nThe `state` is `finalized` status, that is, the data is all updated and ready to return. \\nOr the `value` is `isDraftable`, that is, if it is not a type such as object or array with mutable,\\nthere is no reason to make it a proxy, so it returns as it is.\\n\\n```tsx\\nif (value === peek(state.base_, prop)) {\\n  prepareCopy(state);\\n  return state.copy_[prop] = createProxy(state.scope_.immer_, value, state)\\n}\\n\\nreturn value\\n```\\nNow, This is logic when creates proxy object. \\nIt calls `prepareCopy` and create child proxy in `copy_`.\\n`prepareCopy` is the function that do shallow copy from `state.base_` to `state.copy_`.\\nIt creates `state.copy_` by coping and saves new proxy in `state.copy_[prop]`.\\nSince then, The values of `base_` and `copy_` is not same. \\n\\nThrough these logics, even if we refer to the deep tree, it is implemented so that we can get proxy object if it is an object.\\n\\nSo, if we refer back to the object that we have created proxy with get, should we create proxy object again?\\nOf course, once an object that has created a proxy, it reused what has been made.\\nThe logic that checks for reuse is condition of `value === peek(state.base_, prop)`.\\n\\n##### reuse of already created proxy (`value === peek(state.base_, prop)`)\\n\\n`peek(state.base_, prop)` means `prop` of `base_` and `value` means `prop` of `copy_` or `base_`.\\nBefore `copy_` is created, that is, if we have never done `get`, it always compares `base_` and `base_`\\nso it is always `true` and always run logic to create proxy.\\nHowever, if we have done `get` and `copy_` is created, it compares `copy_` and `base_`.\\nSince the previous get logic allocates proxy to `copy_[prop]` and `copy_` is already different from `base_`, \\nthe logic of creating `proxy` is skipped and the `state.copy_` is returned as it is.\\n\\nTo use this way, `immer` prevent unnecessary to create `proxy` in `get`. \\n\\nIt is complicated to explain one line at a time by code, \\nbut summarize what we do in the `get` logic of proxy.\\n\\n1. If the referred value from object is not object, it just return it is.\\n2. If the referred value from object is object, create and return proxy.\\n3. If it is an object that has been referenced once, reuse the previously created proxy.\\n\\n#### Set\\nThe purpose of set logic is to update an object and set a `modified_` flag that the object is updated.\\n\\n```tsx\\n// https://github.com/immerjs/immer/blob/master/src/core/proxy.ts#L131-L173\\nexport const objectTraps = {\\n  set(state, prop, value) {\\n    if (!state.modified_) {\\n      const current = peek(latest(state), prop)\\n      const currentState = current?.[DRAFT_STATE]\\n      \\n      if (is(value, current) && has(state.base_, prop)) return;\\n\\n      prepareCopy(state);\\n      markChanged(state);\\n    }\\n\\n    if (state.copy[props] === value) return;\\n\\n    state.copy_[props] = value;\\n    return;\\n  }\\n} \\n```\\nThe abbreviation of the main logic used in the set is as above.\\n```tsx\\nset() {\\n  ...\\n  if (state.copy[props] === value) return;\\n\\n  state.copy_[props] = value;\\n  return;  \\n}\\n```\\nLooking at the logic that proceeds regardless of whether it is `modified_`, \\nit can be seen that only `copy_` is changed without changing the original data(`base_`) when setting.\\n\\nIn this process, we can see that if new value has the same reference as the value stored in `copy_`, \\nit doesn\'t do update. As a result, it can also be confirmed that unnecessary updates are being prevented.\\n\\nIf object to be updated has no changed history, `modified_` would be false, but the `modified_` flag is changed in set logic.\\n```tsx\\nset(state, prop, value) {\\n  if (!state.modified_) {\\n    const current = peek(latest(state), prop)\\n    const currentState = current?.[DRAFT_STATE]\\n    \\n    if (is(value, current) && has(state.base_, prop)) return;\\n\\n    // highlight-start\\n    prepareCopy(state);\\n    markChanged(state);\\n    // highlight-end\\n  }\\n  ...\\n}\\n```\\nIf `modified_` is false when proceeding with the set, the change logic is performed.\\nExcept for edge logic, if we look at basic logic, it perform the functions `prepareCopy` and `markChanged`. \\n \\n:::info\\n#### `prepareCopy` from get and `prepareCopy` from set\\n\\nPreviously, we saw the use of `prepareCopy` when proceeding with get.\\nDoes it do copy when we get and copy when we set?\\n\\nIf we look closely, `prepareCopy` of get and `prepareCopy` of set have different purposes.\\n\\n`prepareCopy` of `get` do that copy parent object about referred object \\nand `prepareCopy` of `set`do that copy itself about referred object.\\n\\nFor example, if the object is changed to `proxy.a.b = { ... }`, `copy_` is made through `prepareCopy` from get to `proxy.a`\\nand `proxy.a.b` makes `copy_` through `prepareCopy` in the set.\\n:::\\n\\nThe code of `markChanged` is as follows.\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/proxy.ts#L266-L273\\nexport function markChanged(state: ImmerState) {\\n  if (!state.modified_) {\\n    state.modified_ = true\\n    if (state.parent_) {\\n      markChanged(state.parent_)\\n    }\\n  }\\n}\\n```\\nIn addition to changing one\'s `modified_`, the `modified_` to the root proxy through the `modified_` of the parent object is changed.\\nBy changing the root proxy in this way, it is possible to find which object has been changed from root to leaf.\\n\\nIn addition, let\'s check the edge case when changing `modified_` that was missed in the middle.\\n```tsx\\nset(state, prop, value) {\\n  if (!state.modified_) {\\n    // highlight-start\\n    const current = peek(latest(state), prop)\\n    const currentState = current?.[DRAFT_STATE]\\n    \\n    if (is(value, current) && has(state.base_, prop)) return;\\n    // highlight-end\\n\\n    prepareCopy(state);\\n    markChanged(state);\\n  }\\n  ...\\n```\\nIf the value to be changed is the same as the stored value and the value `base_[props]` exist,\\nit is determined that there is no need to change it. \\nThe process of updating `modified_` true is stopped and updates are not performed.\\nIt seems to be an effort to reduce unnecessary cost by not changing `modified_` when the same value is allocated.\\n\\nNow, the logic of the set is summarized as follows.\\n1. If `modified_` is false, copies from `base_` to `copy_` itself and updates `modified_` from parents to root including oneself true.\\n2. Regardless of whether it is modified or not, it allocates a value to be changed to `state.copy_`. \\n\\n### Recap of Proxy\\nLet\'s summarize the role of proxy objects in the immer.\\n- When referring to data, if it is an object, it creates a proxy object. \\nWhen referred to multiple depth in an object several times, get proceeds sequentially, \\nso all objects from root object to target object are generated as proxy.\\nThanks to this, when referring to objects in multi depth, the same proxy logic as the root can be used.\\n- When allocating data, `base_` is shallowly copied to `copy_` and a value is updated to the object `copy_` is updated.\\nIn this case, if an object that has not been updated is updated, all modifications from the object to the root object through the parent object are set to true. \\n\\n## finalize\\nIf all data have been updated through the `recipe` function, the finalization process is now performed.\\nIt is a process of appropriately combining `base_` and `copy_`.\\n\\nLooking at the product code again, it is as follows. <br/>\\nHere, the logic for `processResult(result, scope)` is confirmed.\\n\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/immerClass.ts#L66-L122\\nexport class Immer {\\n  produce: (base, recipe) {\\n    let result;\\n\\n    const scope = enterScope(this);\\n    const proxy = createProxy(this, base, undefined);\\n    \\n    result = recipe(proxy);\\n    // highlight-start\\n    return processResult(result, scope);\\n    // highlight-end\\n  }\\n}\\n```\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/finalize.ts#L22-L56\\nexport function processResult(result, scope) {\\n  const baseDraft = scope.drafts_[0];\\n  const isReplaced = result !== undefined;\\n  \\n  if (isReplaced) {\\n    result = finalize(scope, result);\\n  } else {\\n    result = finalize(scope, baseDraft, []);\\n  }\\n}\\n```\\nThe `finalize` process is largely divided into two. This is the case of returning in `recipe` or not.\\nThe difference between these two lies in the variable that is put as a function of `finalize`.\\nIf `recipe` is returning, `finalize` do based on the result value.\\nIf `recipe` is not returning, `finalize` do based on the root proxy.\\n\\n### using finalize with root proxy\\nIf `recipe` is not returning, `finalize` is automatically performed using root proxy.\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/finalize.ts#L57-L110\\nfunction finalize(rootScope, value, path) {\\n  ...\\n  if (!state.modified_) {\\n    return state.base_;\\n  }\\n  \\n  if (!state.finalized_) {\\n    state.finalized_ = true;\\n    const result = state.copy_;\\n    \\n    each(result, (key, childValue) => finalizeProperty(...));\\n  }\\n  \\n  return state.copy_;\\n}\\n```\\nIn here, value means root proxy. If root proxy has `modified_` as false, it means that the internal object has never been changed.\\nTherefore, It returns `state.base_` as it is.\\nIt `modified_` is true because it has been changed, `finalized` is checked. To prevent the finalized logic from being performed several times,\\nwhen the finalized logic is entered, the `finalized_` is changed to true and the logic proceeds.\\nIn ES5 mode that does not use proxy, several logics proceed, but in proxy mode, `state.copy_` is used as it is.\\n`finalizeProperty` including `each` is an operation to `finalize` all child objects inside the root proxy.\\nIf the finalization of all child objects is completed, the `immer` logic ends by returning `state.copy_`.\\n\\n### using finalize with return of recipe\\nIf `recipe` has a return value, `finalize` is performed using the return value. Of course, the return value is a plane object.\\n```tsx\\n// https://github.com/immerjs/immer/blob/v9.0.6/src/core/finalize.ts#L57-L110\\nfunction finalize(rootScope, value, path) {\\n  const state = value[DRAFT_STATE];\\n  \\n  if (!state) {\\n    each(value, (key, childValue) => finalizeProperty(...))\\n    return value;\\n  }\\n  ...\\n}\\n```\\nIf `immer` refers `value[DRAFT_STATE]` in value of plain object, It has to be undefined.\\nTherefore, it proceeds to the logic of `if (!state)`.\\nIn the same way as `finalize` using root proxy, all child objects are finalized through `finalizeProperty` and then the value is returned.\\n\\nIn this time, all child objects may be considered to be plain objects, not proxy objects,\\nbut since all objects approaching inside `recipe` are changed to proxy and returned by proxy\'s get operation,\\nthe child object may be proxy even if the root is not proxy. \\nTherefore, it is necessary to proceed with finalize all child objects.\\n\\n## Recap\\n- `immer` receives the `baseState` object and the `recipe` callback function and performs both the mutable logic inside the `recipe`, \\nwhich returns the updated new object without changing the existing object.\\n- When receive `baseState`, first `immer` creates `Proxy` object using `baseState` and manages it.\\n- Although the proxy object has several data, but main data are `base_` and `copy_`. \\nIt is managed that `base_` is original data and `copy_` is updated data.  \\n- The `recipe` callback function logic is executed with the previously created proxy object, \\nwhere the method of not performing mutable logic is because it intercepts basic object actions such as proxy\'s set and get.\\n- In the get of `Proxy`, all the objects it meets are returned to `Proxy` so that it can create `Proxy` even if we refer to the depth of the object.\\n- In the set of `Proxy`, the `modified_` flag managed inside the proxy object is viewed to manage whether to change or not,\\nand the `copy_` object, not the `base_` object, is updated.\\n- After performing both proxy logic using set and get of proxy in the `immer`, \\nthe changed object uses the information of the proxy object to use the updated object(`copy_`) \\nand the unchanged object uses the original object(`base_`) to create and return a new object.\\n\\n## Answer the question\\n:::tip Question\\nQ1. How does `immer` change the mutable update way to immutable update way?\\n:::\\n\\nA1. Because `immer` is intercepting get and set logic to using `new Proxy`,\\nObject is not mutated directly even if update object mutably.\\nIn the logic of set, the `copy_` is copied from `base_` and `immer` updates `copy_` without changing `base_`. \\n\\nAfter all updates are completed, it is possible to immutably update the object \\nby determining whether the object has been changed and returning `copy_` or `base_`.\\n\\n:::tip Question\\nQ2. How does `immer` use `structural sharing`?\\n:::\\n\\nA2. `immer` manages the value of `modified_` according to whether the object is changed.\\nIf `modified_` is true, it means that object is updated.\\nIf `modified_` is true, return a new object called `copy_` to use a new reference,\\nIf `modified_` is false, `base_` object, original object, is returned with previous reference.  \\nTherefore, boolean is managed whether it has been changed or not,\\nand structural sharing is used to use the existing one or the new one depending on whether it has been changed.\\n\\n:::tip Question\\nQ3. `immer` sometimes updates data through return rather than mutable updating the draft within `produce` function,\\nin which case the logic is different?\\n:::\\n\\nWhether to return within the `produce` function differs in the `finalize` of the `immer`, in the process of preparing the updated object.\\nIf return is not made, it means that the object has been directly changed inside `produce`, \\nand if so, using the proxy logic get, set implemented by immer, it is that the object has been updated.\\nThen, Object updates are carried out using various variables and logics such as `base_`, `copy_` and `modified_` as discussed in this article.\\n\\nHowever, what would happen if I returned?\\nIf there is a return value in `produce`, it means that the result value is returned as it is without using logic such as proxy get and set prepared by `immer`.\\nTherefore, it skips all logic and moves on to the `finalize` process, such as forming a root proxy, updating objects through get, and changing `modified_` to set.\\nThis means returning results without using most of the `immer`\'s logic.\\n\\nBoth methods manage objects immutably and update them. \\nAnd both methods use structural sharing in which only the changed object changes its reference.\\nOf course, if you use the second method, the method of returning the updated object,\\nyou need to be careful not to create a new object unnecessarily.\\nAs a result, either side is the same.\\nTo choose the difference, it is only about hot to change the object. If so, it is an area of choice.\\nYou can think about whether to choose a method of changing it to be mutable or immutable.\\n\\nOf course, speaking of my opinion, I think the way we update an object depends on the purpose of how we want to update it.\\nTherefore, I think we can understand the advantages and disadvantages of changing to immutable and the advantages and disadvantages of changing to mutable,\\nand mix them according to the situation.\\n\\n## Reference\\n- [immer official docs](https://immerjs.github.io/immer/)\\n- [immer repository v9.0.6](https://github.com/immerjs/immer/tree/v9.0.6)\\n- [redux style guide](https://ko.redux.js.org/style-guide/style-guide/#use-redux-toolkit-for-writing-redux-logic) \\n- [redux-toolkit guide](https://redux-toolkit.js.org/api/createReducer#direct-state-mutation)\\n- [[blog] Introducing immer: Immutability the easy way](https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3#3bff)\\n- [Proxy MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)"},{"id":"how-to-time-travel-debugging-at-redux-devtools","metadata":{"permalink":"/en/how-to-time-travel-debugging-at-redux-devtools","source":"@site/i18n/en/docusaurus-plugin-content-blog/2021-10-02-how-to-time-travel-debugging-at-redux-devtools.md","title":"how to time travel debugging at redux-devtools","description":"We will check how to time travel debugging at redux-devtools.","date":"2021-10-02T00:00:00.000Z","formattedDate":"October 2, 2021","tags":[{"label":"redux","permalink":"/en/tags/redux"},{"label":"redux-devtools","permalink":"/en/tags/redux-devtools"},{"label":"time-travel","permalink":"/en/tags/time-travel"},{"label":"library","permalink":"/en/tags/library"},{"label":"how-to-work","permalink":"/en/tags/how-to-work"},{"label":"javascript","permalink":"/en/tags/javascript"},{"label":"web","permalink":"/en/tags/web"}],"readingTime":24.005,"truncated":true,"authors":[{"name":"Hyunmo Ahn","title":"Front End Engineer @ Line Financial+","url":"https://github.com/HyunmoAhn","imageURL":"https://github.com/HyunmoAhn.png","key":"HyunmoAhn"}],"frontMatter":{"slug":"how-to-time-travel-debugging-at-redux-devtools","title":"how to time travel debugging at redux-devtools","description":"We will check how to time travel debugging at redux-devtools.","keywords":["redux","redux-devtools","time-travel","javascript"],"authors":"HyunmoAhn","tags":["redux","redux-devtools","time-travel","library","how-to-work","javascript","web"]},"prevItem":{"title":"Deep dive to immer","permalink":"/en/deep-dive-to-immer"},"nextItem":{"title":"How to cancel at axios","permalink":"/en/how-to-cancel-at-axios"}},"content":"## Purpose\\nIf you used [redux](https://redux.js.org/) in web application devlopment, you may have experience to use time-travel debugging with [redux-devtools](https://github.com/zalmoxisus/redux-devtools-extension).\\n\\nIf you have confused about what `redux-devtools` is, please see below video.\\n<iframe style={{ width: \\"100%\\", height: \\"100%\\" }} src=\\"https://www.youtube.com/embed/VbPgAf3FUU8\\" title=\\"YouTube video player\\" frameBorder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\\" allowFullScreen />\\n\\nIf you don\'t have any experience about `redux-devtools`, I think it may be difficult to understand this article.\\n\\n`redux-devtools` records the redux information(action, reducer state) of web applications using redux,\\nrollback to the reducer at a specific point in time and can pretend that there was no specific action.\\nHowever, It is not simple to try to implement similar actions inside web applictions without using `redux-devtools`.\\nFor example, If you press the A button, make as if The action that\'s been happening so far didn\'t happen \\nor if you leave before pressing the Submit button, rollback all actions that occurred on the page.\\n\\n`redux-devtools` is an easy to provide function with buttons, but I don\'t know how to implement it myself.\\nHow does `redux-devtools` make these things possible?\\n\\nIn this article, we will check below three things.\\n- How to **log** the actions and reducer called in `redux-devtools`.\\n- How to **jump** to a point where specific action is dispatched in `redux-devtools`.\\n- How to **skip** a specific action as if it did not work in `redux-devtools`\\n\\n:::info PREREQUISITES\\n- The experience about [redux-devtools](https://github.com/zalmoxisus/redux-devtools-extension)\\n- The intelligence about [redux](https://redux.js.org/) enhancer\\n:::\\n:::caution Caution\\n- This article doesn\'t include content of `browser extension`\\n- This article will say about core of `redux-devtools` and you can understand if you don\'t know about `browser extension`<br/>\\n- If you want to know `browser extension`, It may not fit the purpose of this article.\\n:::\\n\\n\x3c!--truncate--\x3e\\n\\n## How to connect redux-devtools and web application?\\nWe need to know how `redux-devtools` can affect web applictions.<br />\\nFirst, we will check guide to use `redux-devtools`\\n\\n### Simple usage\\nThe way to apply redux-devtools with chrome extension is below. ([docs](https://github.com/zalmoxisus/redux-devtools-extension#11-basic-store)) \\n```tsx\\n const store = createStore(\\n   reducer, /* preloadedState, */\\n+  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\\n );\\n```\\nWhen we create `redux store`, we inject `window.__REDUX_DEVTOOLS_EXTENSION__` in `enhancer`.\\nWe know that `redux-devtools` use `enhancer` of `redux store`, but we can\'t knwo where `window.__REDUX_DEVTOOLS_EXTENSION__` is registered.\\nAnd, if you used [redux-toolkit](https://github.com/reduxjs/redux-toolkit), you might not have cared about devtools because devtools options is [set true at default value](https://github.com/reduxjs/redux-toolkit/blob/v1.6.1/packages/toolkit/src/configureStore.ts#L63).\\n`redux-toolkit` also inject same setting code internally.([code](https://github.com/reduxjs/redux-toolkit/blob/v1.6.1/packages/toolkit/src/devtoolsExtension.ts#L184))\\n\\nI guess `window.__REDUX_DEVTOOLS_EXTENSION__` is injected from Chrome extension. But we don\'t read Chrome extension code, we will find another usage about `redux-devtools`.\\n\\n### Manual usage\\nIf we look for `redux-devtools` document, we can find document that manually apply redux-devtools without using `browser extension`.   \\n\\nIn short about that document, add below dependency and create `createDevTools` and add it at store enhancer.\\n- install dependency\\n```shell\\nnpm install --save-dev @redux-devtools/core\\nnpm install --save-dev @redux-devtools/log-monitor\\nnpm install --save-dev @redux-devtools/dock-monitor\\n```\\n- create `DevTools` component\\n```tsx\\n// DevTools.tsx\\nimport React from \'react\';\\n\\nimport { createDevTools } from \'@redux-devtools/core\';\\nimport LogMonitor from \'@redux-devtools/log-monitor\';\\nimport DockMonitor from \'@redux-devtools/dock-monitor\';\\n\\nconst DevTools = createDevTools(\\n  <DockMonitor\\n    toggleVisibilityKey=\\"ctrl-h\\"\\n    changePositionKey=\\"ctrl-q\\"\\n    defaultIsVisible={true}\\n  >\\n    <LogMonitor theme=\\"tomorrow\\" />\\n  </DockMonitor>\\n);\\n\\nexport default DevTools;\\n```\\n\\nwe will create `DevTools` component using `createDevTools` interface in `redux-devtools/core`.\\nThis `DevTools` component have two roles.\\nFirst is a devtools component to show inner web application. By manual usage, it is possible to use a way that can be operated by displaying devtools on web application rather than by browser extension.\\n`DevTools` is a component that displayed in web application.\\nSecond is the instrument method that is served in `DevTools`. \\nThis method return enhancer to use redux store. As it will follow, connect web application and redux-devtools through these two.\\n\\n- Inject enhancer in store & Render `DevTools`\\n```tsx\\n// Store.ts\\nimport { createStore, applyMiddleware, compose } from \'redux\';\\nimport DevTools from \'./DevTools\';\\n\\nconst enhancer = compose(\\n  // Middleware you want to use in development:\\n  applyMiddleware(d1, d2, d3),\\n  // Required! Enable Redux DevTools with the monitors you chose\\n  DevTools.instrument()\\n);\\nconst store = createStore(rootReducer, initialState, enhancer);\\n\\nexport default store;\\n```\\n```tsx\\n// App.tsx\\nimport React from \'react\';\\nimport { render } from \'react-dom\';\\nimport { Provider } from \'react-redux\';\\n\\nrender(\\n  <Provider store={store}>\\n    <div>\\n      <TodoApp />\\n      <DevTools />\\n    </div>\\n  </Provider>\\ndocument.getElementById(\'app\')\\n);\\n```\\nThe above code is the example of the part used for store enhancer and component the created `DevTools`. \\n\\nNow, we can figure out what to check to see the contents of redux-devtools.<br/>\\n`redux-devtools` is connected to web applications in the form of component and redux store enhancer, and we can check the inside of `@redux-devtools/core`.\\n\\nIn here, We will check only `@redux-devtools/core` in this article \\nbecause  `DockMonitor` or `LogMonitor` is an additional function to display redux-devtools inside of web applications.\\n\\n### Recap about devtools connection with web application\\nThe link between `redux-devtools` and `web application` was able to get hints through a [manual usage])(https://github.com/reduxjs/redux-devtools/blob/main/docs/Walkthrough.md#manual-integration) rather than a usage using browser extension. \\n\\n`@redux-devtools/core` is serving `createDevTools` function and it provides a component that renders devtools, while at the same time creating an enhancer to inject redux store.\\n\\nNow we can find hint, we will check about `createDevTools` of `@redux-devtools/core`.\\n\\n## createDevTools\\n[createDevTools](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools/src/createDevTools.js#L24) has component to render `DevTools` and method to create enhancer in registered redux store. \\nWe will check about enhancer.\\n```tsx\\nimport instrument from \'redux-devtools-instrument\';\\n\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools/src/createDevTools.js#L24\\nexport default function createDevTools(children) {\\n  const Monitor = monitorElement.type;\\n  ...\\n  return class DevTools extends Component {\\n    static instrument = options => instrument(\\n      (state, action) => Monitor.update(monitorProps, state, action),\\n      options,\\n    )\\n    \\n    render() {\\n      ...\\n    }\\n  }\\n}\\n```\\n`createDevTools ` serve `instrument` as a static function and it is [redux-devtools-instrument](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L737)\\n\\n## redux enhancer\\n`DevTools.instrument()` is used in store enhancer. So, we can expect that [instrument](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L737) is return enhancer function.\\nBefore we study `instrument`, Let\'s recap about redux enhancer.\\n\\n[redux store enhancer](https://redux.js.org/usage/configuring-your-store#enhancersmonitorreducerjs) form is below.\\n```tsx\\n// https://redux.js.org/usage/configuring-your-store#enhancersmonitorreducerjs\\nconst exampleEnhancer = (createStore) => (reducer, initialState, enhancer) => {\\n  const monitorReducer = (state, action) => {\\n    const start = performance.now()\\n    const newState = reducer(state, action)\\n    const end = performance.now()\\n    const diff = round(end - start)\\n\\n    console.log(\'reducer process time:\', diff)\\n\\n    return newState\\n  }\\n  \\n  return createStore(monitorReducer, initialState, enhancer) \\n}\\n```\\n`enhnacer` get `createStore` parameter and return function that return store.  \\nAbove code is an example of redux document, It has a role that make `monitorReducer` and replace existing reducer.\\n\\n`enhancer` mutate reducer or state in this method. `redux-devtools` also use the redux enhancer features to implement logging, rollback and skip features.\\n\\n## instrument\\nThe [instrument](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L737) returns the redux enhancer\\nand the internal structure is as follows.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L737-L771\\nexport default function instrument(monitorReducer, options) {\\n  return (createStore) => (reducer, initialState, enhancer) => {\\n    function liftReducer(r) {\\n      return liftReducerWith(r, initialState, monitorReducer, options);\\n    }\\n  }\\n  \\n  const liftedStore = createStore(liftReudcer(reducer), enhancer);\\n  \\n  return unliftStore(liftedStore, liftReducer, options);\\n}\\n```\\nNow, it returns result of `unliftStore` function and reducer is processed through `liftReducer`.\\n\\nTo give you an additional explanation to make it easier to understand,\\n`redux-devtools` create another store of devtools separately from the store of app.\\nIn other words, the app creates and uses a redux store, but devtools creates and uses a redux store different from the app.\\nThe words `lift` and `unlift` are used for these two distinction, as can be seen in the function name used in `instrument`.\\n\\n`lift` means raising app information to devtools. And `unlift` means pulling down devtools information so that it can be used on the app. \\nTo infer the role of `liftReducer` and `unliftStore` based on this assumption,\\n`liftReducer` is reducer used in devtools and `liftedStore` means that it is store used in devtools.\\nIn contrast, `unliftStore` can be understood as meaning that create a store used in the app using `liftStore` that used in devtools. \\n\\nOf course, it is not an official expression found in the devtools document, but I brought it \\nbecause I thought it would be good to understand devtools in this way. \\n\\n:::tip TIP\\n`redux-devtools` is separated with app\'s store and devtools\'s store.<br/>\\n`lift` means replacing what is app with that of devtools and `unlift` means replacing what is devtools that of app.\\n\\nFor example, `unliftStore` is function that get store of app using `liftedStore`(store of devtools).\\n\\nIt is not official commentary, if you check the code of redux-devtools with this meaning, it will be easier to understand.\\n:::\\n\\n## unliftStore\\nLet\'s see [unliftStore](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L680-L732) used in return of `instrument` first. \\n`unliftStore` is a function that create store used in app.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L680-L732\\nexport function unliftStore(liftedStore, liftReducer, options) {\\n  function getState() { ... }\\n  function dispatch() { ... }\\n  \\n  return {\\n    ...liftedStore,\\n    liftedStore,\\n    dispatch,\\n    getState,\\n    replaceReducer() { ... },\\n    [$$observable]() { ... },\\n  }\\n}\\n```\\n`unliftStore` has several methods such as dispatch, getState, replaceReducer and the method names are familiar for us.  \\nBecause this is served method by redux.\\nIn other word, `unliftStore` doesn\'t use `createStore` but it returns store of redux.\\nBecause `unliftStore` is used for redux store enhancer and the return value of redux store,\\nIt may be natural that the return value of `unliftStore` is the same as the redux store\\n\\n### getState\\n`getState` of redux store has a role to return state object of redux store.\\n`getState` of return value of `unliftStore` is used in app part rather than devtools.\\nSo, we can expect that `getState` will return state of redux store on app.\\nLet\'s take a look at the code.\\n\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L685-L691\\nfunction getState() {\\n  return unliftState(liftedStore.getState());\\n  if (state !== undefined) {\\n    lastDefinedState = state;\\n  }\\n  return lastDefinedState;\\n}\\n\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L671-L674\\nfunction unliftState(liftedState) {\\n  const { computedStates, currentStateIndex } = liftedState;\\n  const { state } = computedStates[currentStateIndex];\\n  \\n  return state;\\n}\\n```\\n`getState` calls `unliftState` and `unliftState` returns state.\\nIf we think means of `lift` and `unlift`, `unliftState` means state used on app.\\nSo, `getState` returns `unliftState`(app\'s redux state) from state of `liftStore`(devtools store). \\n\\nInside of `unliftState`, it extract state using `computedStates` and `currentStateIndex` from `liftedState`.\\nIn other words, we can expect when data is saved, `liftState` saves all app state in `computedStates` and saves index of state in `currentStateIndex`.  \\nOf course, we can\'t know how to make `liftState` yet. Let\'s guess this much and keep reading.\\n\\n:::note Note\\n`unliftState` is a function that returns `unliftState` from `liftedState`.<br/>\\nLet\'s remember that we don\'t know that `liftedState` has what kind of data,\\nbut `liftedState` are looking for the state of the app through `computedStates` and `currentStateIndex`.\\n:::\\n\\n### dispatch\\nThis `dispatch` is also dispatch used in app. Let\'s take a look some code. \\n\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L693-L696\\nfunction dispatch(action) {\\n  liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch))\\n\\n  return action;\\n}\\n\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L246-L253\\nfunction liftAction(action, trace, traceLimit, toExcludeFromTrace) {\\n  return ActionCreators.performAction(\\n    action,\\n    trace,\\n    traceLimit,\\n    toExcludeFromTrace\\n  );\\n}\\n```\\nThe action from parameter of `dispatch` is the action object defined in app because the method of `unliftStore` will be use directly in app. It is not exception about `dispatch`.\\nSo, `liftedStore`(devtools store) transfer action from app to use dispatch, but action is not transmitted directly, it is converted by `liftAction` and it will change action of app to action of devtools.   \\nLet\'s see inside of `liftAction`.\\n[ActionCreators.performAction](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L38-L97) is an action object having an action type as `PERFORM_ACTION`. \\nSo, all actions that dispatched in app, are converted to `PERFORM_ACTION` and used in `liftedStore`.\\n\\nLet\'s think about flow included `redux-devtools` when we dispatch actions.\\n1. `action` is dispatched from app.\\n2. `dispatch` convert `action` to `liftedAction` inside.\\n3. `liftedAction` is called through `liftedStore.dispatch` and consumed in `liftedStore`.\\n\\nIn this flow doesn\'t have flow to call dispatch of app.\\nThe process of updating the state by handling over the action to the reducer, which is the role of the [original dispatch](https://github.com/reduxjs/redux/blob/master/src/createStore.ts#L257-L262), was not included.\\nTherefore, the dispatch has a role that converts action of app to `PERFORM_ACTION` and calls dispatch of the `liftedStore` without changing the state of the app.\\n\\n### Recap about unliftStore\\n- `unliftStore` returns the store form as it is. In other words, it returns `getState` and `dispatch`.\\n- `unliftStore.getState` returns redux state of app and it is identifying the state of the app using `computedStates` and `currentStateIndex` of `liftedState`\\n- `unliftStore.dispatch` changes all actions to `PERFORM_ACTION` and calls `liftedStore.dispatch`.\\n  - The operation of updating the state of the app of the original dispatch has not yet been performed.\\n\\n## liftReducer\\nLet\'s take a look `instrument` code again.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L737-L771\\nexport default function instrument(monitorReducer, options) {\\n  return (createStore) => (reducer, initialState, enhancer) => {\\n    function liftReducer(r) {\\n      return liftReducerWith(r, initialState, monitorReducer, options);\\n    }\\n  }\\n  \\n  const liftedStore = createStore(liftReudcer(reducer), enhancer);\\n  \\n  return unliftStore(liftedStore, liftReducer, options);\\n}\\n```\\nThrough the previous process, we could understand that `unliftStore` has a role to use new method like `getState` or `dispatch` by redefine.<br />\\nThe next thing to look at is `liftStore` and `liftReducer`. `createStore` used in `liftStore` is served by `redux` \\nso if only `liftReducer` is confirmed, we can know that the secret of time-travel debugging.\\n\\nAccording to the term `lift`, [liftReducer](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L258-L666) means\\nthat reducer used in `devtools`.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L258-L666\\nexport function liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\\n  const initialLiftedState = { ... };\\n  ...\\n  return (liftedState, liftedAction) => {\\n    ...\\n    switch (liftedAction.type) {\\n      case ActionTypes.PERFORM_ACTION: {\\n        ...\\n      },\\n      ...\\n    }\\n  }\\n}\\n```\\n`liftReducerWith` has long size of code. According to the term `reducer`, it has initial state(`initialLiftedState`) and makes condition state by `liftedAction.type`.\\nBecause we saw `unliftStore`, we know that all actions from app are converted to `PERFORM_ACTION` and are transmitted to `liftReducer`.\\n\\nTherefore, we will check the initialState of reducer and check the behavior when `PERFORM_ACION` is dispatched. \\n\\n### initialState\\n`initialState` of `liftReducer` is below.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L264-L275\\nconst initialLiftedState = {\\n  monitorState: monitorReducer(undefined, {}),\\n  nextActionId: 1,\\n  actionsById: { 0: liftAction(INIT_ACTION) },\\n  stagedActionIds: [0],\\n  skippedActionIds: [],\\n  committedState: initialCommittedState,\\n  currentStateIndex: 0,\\n  computedStates: [],\\n  isLocked: options.shouldStartLocked === true,\\n  isPaused: options.shouldRecordChanges === false\\n};\\n```\\nWe don\'t know what data is saved roughly by looking at the `initialState`, but we\'ve checked which one of the `liftState` is used in `unliftState`. \\n:::note Note\\nWhat mentioned in `unliftState`\\n  - In other words, we can expect when data is saved, `liftState` saves all app state in `computedStates` and saves index of state in `currentStateIndex`.\\n:::\\n`unliftState` computed using `computedStates` and `currentStateIndex`, \\nSo `computedStates` save data of app\'s state and `currentStateIndex` save index about current state index.\\n\\nWhen looking at other predictable states, `actionId` seems to store action data on id and `stagedActionIds` or `skippedActionIds` seems that save actionId about action status like `staged` or `skipped`.\\n`isLocked` or `isPaused` is option about devtools. First, let\'s just organize the contents below and move on.\\n\\n#### recap about initialState\\n- devtools saves byId and id forms about action data to [normalized](https://redux.js.org/usage/structuring-reducers/normalizing-state-shape) form.   \\n- we expect that `computedStates` saves all state and `currentStateIndex` seems that save index what kind of state is used in `computedStates`.  \\n- devtools has options value like `isLocked` or `isPaused`.\\n\\n### The behavior of PERFORM_ACTION\\nWe checked that all action dispatched in app is converted `PERFORM_ACTION` and is used in `liftReducer`.\\nSo, Let\'s check how `PERFORM_ACTION` will operate in the `liftReducer`.\\n\\nBefore see the reducer, Let\'s check payload of `PERFORM_ACTION`.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L38-L97\\nexport const ActionCreators = {\\n  performAction(action, trace, traceLimit, toExcludeFromTrace) {\\n    ...\\n    return {\\n      type: ActionTypes.PERFORM_ACTION,\\n      action,\\n      timestamp: Date.now(),\\n      stack,\\n    }\\n  }\\n}\\n```\\n`PERFORM_ACTION` stores the action received as a factor as it is and doesn\'t particularly store other data. \\nIf you see the code following links, you can see complicate logic like `stack`.\\nThis is because devtools has various logics to show the trace function. But our purpose is not to look at trace, it will be okay pass lightly.\\n\\nNot that we have seen the form of action, let\'s look at the reducer part.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L426-L446\\nexport function liftReducerWith() {\\n  ...\\n  let minInvalidatedStateIndex = 0;\\n  ...\\n  swtich (liftedAction.type) {\\n    case ActionTypes.PERFORM_ACTION: {\\n      ...\\n      if (currentStateIndex === stagedActionIds.length - 1) {\\n        currentStateIndex++;\\n      }\\n      const actionId = nextActionId++;\\n      actionById[actionId] = liftedAction;\\n      stagedActionIds = [...stagedActionIds, actionId];\\n      minInvalidatedStateIndex = stagedActionIds.length - 1;\\n      break;\\n    }\\n    ...\\n  }\\n}\\n```\\nWhen looking at the original code, the logic varies depending on the various conditions, but when you check the basic logic, it comes out simply as above.<br/>\\n`currentStateIndex` is increased, `actionId` is set, `actionById` save action data. And `stagedActionIds` come and `minInvalidatedStateIndex` also come.\\nObviously, `stagedActionIds` is a value that existed in `initialState` and `minInvalidatedStateIndex` is not stored in `initialState` but a local variable.\\nwe don\'t know how to use these yet, so let\'s move on.\\n\\n:::tip TIP\\nwe don\'t know how to work about `stagedActionIds` and `minInvalidatedStateIndex`. However, to explain the role in advance to make it easier to understand, it is as follows. \\n- `stagedActionIds`\\n  - It is array that ids of the action that should be applied in devtools are saved.\\n  - In other words, it save valid action list and when `PERFORM_ACTION` is dispatched, `stagedActionIds` always add it because new action is added.\\n- `minInvalidatedStateIndex`\\n  - In short, `minInvalidatedStateIndex` means the index value of the action that must be recalculated.\\n  - In `PERFORM_ACTION`, `minInvalidatedStateIndex` is  `stagedActionIdex.length - 1`. In other words, `stagedActionIndex` point last index of actions and it means that last action need to recalculate.  \\n:::\\n\\nWe checked how to implement when action is dispatched, we don\'t know how to calculate nextState yet.\\nObviously, it saved action info and saved action id here and there but, we can\'t expect that info calculate nextState.\\nLet\'s show next logic of switch.\\n\\n### Recap about logic of PERFORM_ACTION\\n- `PERFORM_ACTION` brings all the data of the action generated in the app as it is.\\n- all actions that dispatched from app are converted to `PERFORM_ACTION`. So it is performed through a `PERFORM_ACTION` reducer logic.  \\n- In reducer, it increases `currentStateIndex`, save action like byId and ids form and save `minInvalidatedStateIndex`. \\n- The logic to calculate `nextState` is not come yet.\\n- We don\'t know means that `stagedActionIds` and `minInvalidatedStateIndex`, but if we know it in advance, it\'s as follows.\\n  - `stagedActionIds`: A array that saved ids that need to apply actions in devtools.\\n  - `minInvalidatedStateIndex`: A index of action to calculate state. Later, it calculates use this value.\\n\\n## recomputeStates\\nAfter switch logic, `computedState` logic is come. It seems that update state using `recomputeStates`, Let\'s look at.\\n\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L642-L666\\nexport function liftReducerWith() {\\n  ...\\n  computedStates = recomputeStates(\\n    computedStates,\\n    minInvalidatedStateIndex,\\n    reducer,\\n    committedState,\\n    actionsById,\\n    stagedActionIds,\\n    skippedActionIds,\\n    options.shouldCatchErrors\\n  );\\n  \\n  return {\\n    monitorState,\\n    actionsById,\\n    nextActionId,\\n    stagedActionIds,\\n    skippedActionIds,\\n    committedState,\\n    currentStateIndex,\\n    computedStates,\\n    isLocked,\\n    isPaused\\n  }\\n}\\n```\\n\\n`recomputeStates` is function that recalculate state when action is dispatched. \\nIn parameters, It seems that gets various information like `computedStates`(currentState), `reducer`, `minInvalidatedStateIndex`, `actionByIds` etc. \\nLet\'s look at the code.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L189-L241\\nfunction recomputeStates(\\n  computedStates,\\n  minInvalidatedStateIndex,\\n  reducer,\\n  committedState,\\n  actionsById,\\n  stagedActionIds,\\n  skippedActionIds,\\n  shouldCatchErrors\\n) {\\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\\n  \\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\\n    const actionId = stagedActionIds[i];\\n    const action = actionsById[actionId].action;\\n\\n    const previousEntry = nextComputedStates[i - 1];\\n    const previousState = previousEntry ? previousEntry.state : committedState;\\n\\n    const entry = computeNextEntry(\\n      reducer,\\n      action,\\n      previousState,\\n      shouldCatchErrors\\n    );\\n    nextComputedStates.push(entry);\\n  }\\n\\n  return nextComputedStates;\\n}\\n```\\nAfter omitting the code for skip or error processing, it becomes the above code.\\nInitially, `nextComputedStates` is prepared and the state up to `minInvalidatedStateIndex` is cut. \\nHere, the meaning of `minInvalidatedStateIndex` may be known.\\n\\nThe value of `minInvalidatedStateIndex` calculated in `PERFORM_ACTION` earlier refers to the index that has recently entered `stagedActionIds`. \\nFor example, If `stagedActionIds` has four ids, `minInvalidatedStateIndex` is three and nextComputedStates` is a array thet three number of value because it save 0 to 3. \\nIn `for` loop, it start calculate from `minInvalidatedStateIndex` and to `stagedActionIds.length`.\\nIn other words, `minInvalidatedStateIndex` means index of action that need to recalculate.   \\n\\n`for` loop logic is simple. Find out id of the current action and take the action from `actionById`, and state is calculated using `computeNextEntry` function.\\n`computeNextEntry` logic is simple. It consists of several functions because it contains logic for errors, and the code related to errors is omitted as follows.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L179-L184\\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\\n  ...\\n  return computeWithTryCatch(reducer, action, state);\\n} \\n\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L153-L174\\nfunction computeWithTryCatch(reducer, action, state) {\\n  let nextError;\\n  const nextState = reducer(state, action);\\n  ...\\n  return {\\n    state: nextState,\\n    error: nextError,\\n  }\\n}\\n```\\nIn other words, It calculates next state using previous state, current action and reducer.\\nThis calculated value is entered entry and this entry is injected the last of `nextComputedStates`. \\n\\nWhen `PERFORM_ACTION` action is dispatched, for loop always work once and calculated state newly is contained `nextComputedStates` array. It will be assigned to `computedStates`. \\nThe `computedStates` changed here is transmitted to state of app.\\n\\n### Recap about recomputeStates\\n- The logic to update state of store in devtools is `recomputeStates` logic in next part of switch.\\n- `recomputeStates` prepares computed state array and computes new state through the for loop based on the index that needs to be calculated and places it in the state array.\\n- `minInvalidatedStateIndex` refers to a start index that requires calculation.\\n- When `PERFORM_ACTION` is dispatched, for loop run only once and the state of current action is appended in previous `computedStates`.\\n\\n## The process that action is consumed with devtools\\nNow we can see how devtools processes an action when an action occurs in the app.\\n\\n- action is called with dispatch on app\\n\\nThe dispatch used when dispatched action in app is [dispatch](#dispatch) of [unliftStore](#unliftstore). \\ndispatch call dispatch of `liftStore` and action is called with converting `PERFORM_ACTION`.\\n\\n- `liftReducer` of `liftStore`\\n\\nAction is called to `PERFORM_ACTION`, and it is consumed at `liftReducer`. If you see [The behavior of PERFORM_ACTION](#the-behavior-of-perform_action), \\nit increases 1 about `currentStateIndex`, saves action info with generating action id and injects actionId in `stagedActionIds` and updates `minInvalidatedStateIndex`.\\n\\nIn `recomputedStates` a new state is calculated based on `minInvalidatedStateIndex`, and in `PERFORM_ACTION`, only the action called this time is calculated.\\nHere, the calculated state is added to the last array of `computedStates`.\\n\\n- get state from app to `getState`\\n\\n`store.getState` to get state from app is same with `dispatch`. It also uses [getState](#getstate) of [unliftStore](#unliftstore) \\n`getState` calculate state to using `computedStates` and `currentStateIndex` in `liftedState`.\\n\\nIf only `PERFORM_ACTION` was dispatched, `currentStateIndex` would have increased by 1 and the return value of `getState` would have brought the state in the last index of `computedStates`. \\n\\n## Analysis of the main behaviour of devtools\\n\\nWe checked that action is processed in devtools, so it is now possible to answer the questions presented at the beginning of the article.\\n\\n### How to log the actions and reducer called in redux-devtools?\\n\\nAbout logging, it can be derived using the information identified so far. \\n\\n:::tip Question & Answer\\n> Q1. How to **log** the actions and reducer called in redux-devtools?\\n\\nA1. `liftReducer` save all information of action in `actionsById` and save all action id in `stagedActionIds`. \\nAlso, It save state by actions in `computedStates`.\\n\\nTherefore, since the order of actions generated in the app, payload data, and state by action are stored, the devtools can take enough logs. \\nIn addition, encapsulation of information on action and state managed by devtools is maintained through getState of `unliftStore`.\\nIn the app, you can proceed with development without understanding these matters.\\n:::\\n\\n### How to **jump** to a point where specific aciton is dispatched in redux-devtools.\\n\\nThere is something we need to look at in order to know how to jump in redux-devtools.\\nWe only looked at `PERFORM_ACTION` in `liftReducer`. All action that dispatched in app is converted to `PERFORM_ACTION`,\\nbut the action dispatched in `devtools` can dispatch other type of action.\\n\\nLet\'s look at how `liftReducer` handles jump related actions.\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L511-#L526\\ncase ActionTypes.JUMP_TO_STATE: {\\n  currentStateIndex = liftedAction.index;\\n  minInvalidatedStateIndex = Infinity;\\n  break;\\n}\\ncase ActionTypes.JUMP_TO_ACTION: {\\n  const index = stagedActionIds.indexOf(liftedAction.actionId);\\n  if (index !== -1) currentStateIndex = index;\\n  minInvalidatedStateIndex = Infinity;\\n  break;\\n}\\n```\\nThis is the part that processes the action in `liftReducer` that we have seen before.\\n\\nThere will be a difference between calling based on state or action, but both have the same principle.\\nIt is to allocate `currentStateIndex` as the index of the action to jump.\\n\\n`getState` brings state from `computedStates` based on updated `currentStateIndex`.\\nFor example, `computedState` has 5 state and `currentStateIndex` is set 4 then `getState` will return last state of `computedStates`. \\nIn this time, we suppose that currentStateIndex will be changed to 2 by `JUMP_TO_STATE` action. Then `getState` will return 3 index of `computedStates` \\nand store of app back to the state when third action was dispatched.\\n\\nSince `computedStates` and `stagedActionIds` is not mutated, if you come back to `currentStateIndex` using `JUMP_TO_STATE` action, we can come back to original state.\\n\\n:::tip Question & Answer\\n> Q2. How to **jump** to a point where specific aciton is dispatched in redux-devtools.\\n\\nA2. Through the action generated inside devtools, `currentStateIndex` is returned to the previous value \\nand the state suitable for the index is imported, so it is possible to return to the previous state.\\nIn this process, since data on `computedStates` or `stagedActionIds` storing action or state is not changed, the state before jump may return through action.  \\n:::\\n\\n### How to **skip** a specific action as if it did not work in redux-devtools\\n\\nA method to skip as if no action had already occurred confirms `TOGGLE_ACTION`.\\n\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L481-L494\\ncase ActionTypes.TOGGLE_ACTION: {\\n  // Toggle whether an action with given ID is skipped.\\n  // Being skipped means it is a no-op during the computation.\\n  const { id: actionId } = liftedAction;\\n  const index = skippedActionIds.indexOf(actionId);\\n  if (index === -1) {\\n    skippedActionIds = [actionId, ...skippedActionIds];\\n  } else {\\n    skippedActionIds = skippedActionIds.filter(id => id !== actionId);\\n  }\\n  // Optimization: we know history before this action hasn\'t changed\\n  minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\\n  break;\\n}\\n```\\n`TOGGLE_ACTION` also get target actionId and save it on `skippedActionIds` and change `minInvalidatedStateIndex` to index of actionId. \\nThen state that after index of skipped action will be calculated again.\\n\\nSince we didn\'t focus on logic about skipped action, I have never checked where `skippedActionIds` works.\\nSo, we will check `recomputeState` again.\\n\\n```tsx\\n// https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-instrument/src/instrument.js#L218-L222\\nfunction recomputeStates(\\n  computedStates,\\n  minInvalidatedStateIndex,\\n  reducer,\\n  committedState,\\n  actionsById,\\n  stagedActionIds,\\n  skippedActionIds,\\n  shouldCatchErrors\\n) {\\n  ...\\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\\n    const actionId = stagedActionIds[i];\\n    const action = actionsById[actionId].action;\\n\\n    const previousEntry = nextComputedStates[i - 1];\\n    const previousState = previousEntry ? previousEntry.state : committedState;\\n\\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\\n    let entry;\\n    if (shouldSkip) {\\n      entry = previousEntry;\\n    } else {\\n      ...\\n    }\\n    nextComputedStates.push(entry);\\n  }\\n\\n  return nextComputedStates;\\n}\\n```\\nThis time, I omitted the logic except skip. It is same entered for loop, if `actionId` is contained `skippedActionIds`, entry doesn\'t calculate next state \\nand return `previousEntry` like action doesn\'t act.   \\n\\nIn `TOGGLE_ACTION`, since action updates `minInvalidatedStateIndex` to target actionId, states after target index are recalculated \\nso it is possible to set the app as if a specific action did not work.\\n\\nBased on the state, it is summarized as follows.\\n- previous state: [A, B, C, D, E, ...]\\n- skipped action index: 2\\n- after skip state: [A, B, B, D\', E\' ...]\\n\\n:::tip Question & Answer\\n> Q3. How to **skip** a specific action as if it did not work in redux-devtools\\n\\nA2. actionId is put into `skippedActionIds` through an action generated inside devtools.\\nWhen calculating the state for the action included in `skippedActionIds`, return the previous state without calculating the state. \\n\\nSince `minInvalidatedStateIndex`, which stores an index requiring recalculation, has been changed to a target action index,\\nall states after the index are recalculated.\\nSince the target action continues the calculation to the skipped state, the state is formed as if the target action was not called.\\n:::\\n\\n## Recap\\nThrough this article, we checked how `redox-devtools` is connected to the `redux` of the app and how to manage the `redux` data of the app.\\n\\nA brief summary of the core of `redux-devtools` is as follows.\\n- `redux-devtools` is connected to the redux store of the app through a redux store enhancer.\\n- In order not to affect the app while utilizing various functions of `redux-devtools`, two stores, `unliftStore` and `liftStore` are managed. \\n- All actions generated in the app are converted into `liftAction` having a `PERFORM_ACTION` type and transmitted to `liftReducer`.\\n- `liftReducer` stores data on all actions occurring in the app and state on the action.\\n- The redux state used in the app is data obtained from the `getState` of `unliftStore` to the state suitable for the current action. \\n- Various functions used in `devtools` use a method of changing action and state stored through `liftReducer` and delivering the state suitable for the desired time to the app.\\n\\nSome readers of this article may be curious about functions other than `jump` and `skip` of `redux-devtools`.\\nHowever, there is a limit to explaining everything in `redux-devtools`, and I have not checked logic for all functions either.\\nIf you have understood through this article how `redux-devtools` is operating and how it is implementing its main functions (jump, skip),\\nI think you can solve your curiosity by looking at the [@redux-devtools/core](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools/src/index.js) code\\nor analyzing the code of other monitors ([@redux-devtools/log-monitors](https://github.com/reduxjs/redux-devtools/blob/v3.6.0/packages/redux-devtools-log-monitor/src/LogMonitor.js)).\\n\\n## Reference\\n- [redux](https://redux.js.org/)\\n- [redux-devtools](https://github.com/reduxjs/redux-devtools)\\n- [redux-devtools-extensions](https://github.com/zalmoxisus/redux-devtools-extension)"},{"id":"how-to-cancel-at-axios","metadata":{"permalink":"/en/how-to-cancel-at-axios","source":"@site/i18n/en/docusaurus-plugin-content-blog/2021-09-17-how-to-cancel-at-axios.md","title":"How to cancel at axios","description":"The article that how to use cancel logic on axios request.","date":"2021-09-17T00:00:00.000Z","formattedDate":"September 17, 2021","tags":[{"label":"axios","permalink":"/en/tags/axios"},{"label":"library","permalink":"/en/tags/library"},{"label":"how-to-work","permalink":"/en/tags/how-to-work"},{"label":"javascript","permalink":"/en/tags/javascript"},{"label":"web","permalink":"/en/tags/web"}],"readingTime":6.295,"truncated":true,"authors":[{"name":"Hyunmo Ahn","title":"Front End Engineer @ Line Financial+","url":"https://github.com/HyunmoAhn","imageURL":"https://github.com/HyunmoAhn.png","key":"HyunmoAhn"}],"frontMatter":{"slug":"how-to-cancel-at-axios","title":"How to cancel at axios","description":"The article that how to use cancel logic on axios request.","keywords":["axios","javascript","HTTP","cancel","abort"],"authors":"HyunmoAhn","tags":["axios","library","how-to-work","javascript","web"]},"prevItem":{"title":"how to time travel debugging at redux-devtools","permalink":"/en/how-to-time-travel-debugging-at-redux-devtools"}},"content":"## Purpose\\n[axios](https://github.com/axios/axios) support feature to cancel HTTP Request. \\nWe will investigate that how to work about axios cancel logic.\\n\\n:::info Prerequisites\\n- A rough knowledge about HTTP Request\\n- The usage about [Axios](https://github.com/axios/axios) library\\n:::\\n\\n\x3c!--truncate--\x3e\\n\\n## Usage\\nBefore to know that how to work about cancel, We will check that how to use axios cancel.\\n\\n### Simple Usage\\n```tsx\\nimport axios from \'axios\';\\n\\n// Make CancelToken\\nconst CancelToken = axios.CancelToken;\\nconst source = CancelToken.source();\\n\\n// Register Cancel\\naxios\\n  .get(\'/url\', { cancelToken: source.token })\\n  .catch((e) => {\\n    if (axios.isCancel(e)) { /* cancel logic */ }\\n  })\\n\\n// Create Cancel\\nsource.cancel(\'message\');\\n```\\nIf you want to cancel in axios, we need to make `CancelToken`. <br/>\\nEach time axios is requested, `cancelToken` is injected and the axios is canceled through `source.cancel`.\\n\\n### Advanced Usage\\nIf we request multiple axios same time, what action would cancel show?\\n```tsx\\nimport axios from \'axios\';\\n\\n// Make CancelToken\\nconst CancelToken = axios.CancelToken;\\nconst source = CancelToken.source();\\n\\n// Register Cancel\\naxios\\n  .get(\'/url/first\', { cancelToken: source.token })\\n  .catch((e) => {\\n    if (e.code === \'403\') { // session expired \\n      source.cancel(\'session expired\');\\n    } \\n  })\\n\\n// Register Cancel\\naxios\\n  .get(\'/url/second\', { cancelToken: source.token })\\n  .catch((e) => {\\n    if (axios.isCancel(e)) { /* cancel logic */ }\\n  })\\n```\\nThe scenario to be assumed when two axios requests are sent at the same time as above is as follows.\\n- `/url/first` response is faster than `/url/second` response.\\n- `/url/first` will get 403 session expired error code.\\n\\nThen how will the response of `/url/second` be handled?\\n\\nThe answer is that at the time of cancel in `/url/first`, the request for `/url/second` also becomes cancel.\\n\\n**This article starts with curiosity about how cancel in `/url/first` axios affects `/url/second` axios?** \\n\\n:::caution Question\\nQ1. If cancelToken is canceled in one axios request, why others axios request are also canceled?\\n:::\\n\\n## Inner Axios\\n\\n### What about CancelToken\\n[axios](https://github.com/axios/axios/blob/v0.21.1/lib/axios.js#L40-L42) has method associated with Cancel.\\n```tsx\\n// https://github.com/axios/axios/blob/v0.21.1/lib/axios.js#L40-L42\\n// Expose Cancel & CancelToken\\naxios.Cancel = require(\'./cancel/Cancel\');\\naxios.CancelToken = require(\'./cancel/CancelToken\');\\naxios.isCancel = require(\'./cancel/isCancel\');\\n```\\nThe preceding work to cancel axios was that create `CancelToken`.\\nSo, We will watch [axios.CancelToken](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js) first. Because we created token to use `CancelToken.source`. \\n```tsx\\n// https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js\\nCancelToken.source = function source() {\\n  var cancel;\\n  var token = new CancelToken(function executor(c) {\\n    cancel = c;\\n  });\\n  return {\\n    token: token,\\n    cancel: cancel\\n  };\\n};\\n```\\n`source` is simple. It returns the object that has `token` and `cancel` and creates `CancelToken` internally.\\n\\n```tsx\\n// https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js\\nfunction CancelToken(executor) {\\n  var resolvePromise;\\n  this.promise = new Promise(function promiseExecutor(resolve) {\\n    resolvePromise = resolve;\\n  });\\n\\n  var token = this;\\n  executor(function cancel(message) {\\n    token.reason = new Cancel(message); // https://github.com/axios/axios/blob/v0.21.1/lib/cancel/Cancel.js\\n    resolvePromise(token.reason);\\n  });\\n}\\n```\\nTo watch about [CancelToken](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js), It seems complicated about structure. It has two roles.\\n1. Creates promise in `CancelToken`. We can\'t know how to use this promise yet.\\n2. Assigns `function cancel` to cancel in `CancelToken.source` scope. Through this, cancel is connected to the outside of the scope.\\n\\n`CancelToken` make two function that promise and cancel function and when `cancel` is called `promise` is resolved. \\n`cancel` is expanded to `CancelToken.source` scope by `executor` and it will be method to use outside.\\n\\n#### Recap about CancelToken\\n- CancelToken is made by `CancelToken.source`, it will create promise and cancel function.\\n- The generated `cancel` here is transferred as a `CancelToken.source` return value and used as an external usable function. We can\'t know the purpose of promise yet.\\n\\n### Where do use CancelToken.promise?\\n\\naxios uses `adapter` in HTTP request internally and `adapter` has code that associated with `CancelToken.promise`.\\n\\nAmong them, look at the code on the [xhr](https://github.com/axios/axios/blob/master/lib/adapters/xhr.js) side.\\n\\n```tsx\\n// https://github.com/axios/axios/blob/master/lib/adapters/xhr.js#L22-L187\\nvar request = new XMLHttpRequest();\\n\\nrequest.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\\nrequest.onreadystatechange = function handleLoad() {\\n  // HTTP success logic \\n};\\nrequest.send(requestData);\\n```\\nThe basic work is same with logic of [XMLHttpRequest](https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest) generally.\\nIt connects url through `request.open`, handles success flow through `onreadystatechange` and sends HTTP requests through `request.send`.\\nUp to this point, it is the same as the `XMLHttpRequest` in the callback method.\\n\\nIn addition to normal operation, xhr adapter of axios uses cancelToken to use one more promise logic.\\n```tsx\\n// https://github.com/axios/axios/blob/master/lib/adapters/xhr.js#L168-L180\\nif (config.cancelToken) {\\n  // Handle cancellation\\n  config.cancelToken.promise.then(function onCanceled(cancel) {\\n    if (!request) {\\n      return;\\n    }\\n\\n    request.abort();\\n    reject(cancel);\\n    // Clean up request\\n    request = null;\\n  });\\n} \\n```\\n`CancelToken.promise` is used here. Every HTTP request uses cancelToken to call a promise.\\n**In other words, as if using `Promise.race`, it is using logic that handles the first of the two requests of `xhr` and `cancelToken.proimse`.**\\n\\nIf `promise` of cancelToken is resolved, `xhr` request is aborted and `axios` request is end with reject.\\nIn this time, error object is [cancel](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/Cancel.js) Object.\\n\\n`cancelToken` is injected when axios is called, multiple axios request can use same `cancelToken`. So we can answer the first question we had. \\n\\n:::tip Question & Answer\\n> Q1. If cancelToken is canceled in one axios request, why others axios request are also canceled?\\n\\nA1. axios receives cancelToken for every HTTP request, it enters a state of race with xhr requests and promise of cancelToken. \\nIf cancelToken is resolved from another axios request, All axios requests injected with the same cancelToken are terminated with reject because promise is resolved.\\n\\nIn the other words, if cancel occurs in one axios request, the remaining axios requests are also canceled because reject is being performed according to the progress state of cancelToken commonly used\\n:::\\n\\n## Recap\\naxios make race condition by generating not only HTTP requests but also promise associated with cancel. The cancel promise used in this process may be used in several axios requests. <br/>\\nThe promise associated with cancel is created together when creating [cancelToken](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js) and the `cancelToken` also provides a function called `cancel` that resolves the cancel promise.<br/>\\nIf `cancelToken.cancel` is called, cancel promise is resolved and every axios requests that is using canceled `cancelToken` are aborted and will return reject because cancel promise is associated race condition with HTTP request.\\n\\n## Appendix\\nWe checked how to process about axios cancel. In the next article, we will look at the questions encountered when using the axios cancel.\\n\\n### What happens to cancelToken that have already been canceled?\\nSo far, we\'ve learned how to behave when cancelToken is canceled. Then how to work about already canceled `cancelToken`? <br/>\\nLet\'s take a look at [CancelToken](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js) again, which we looked at above.\\nWhen the cancel occurs, [Cancel](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/Cancel.js) is assigned in `CancelToken.reason`. This reason is used to determine whether there is a cancel.\\n\\n```tsx\\n// https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js\\nfunction CancelToken(executor) {\\n  var resolvePromise;\\n  this.promise = new Promise(function promiseExecutor(resolve) {\\n    resolvePromise = resolve;\\n  });\\n\\n  var token = this;\\n  executor(function cancel(message) {\\n    token.reason = new Cancel(message); // https://github.com/axios/axios/blob/v0.21.1/lib/cancel/Cancel.js\\n    resolvePromise(token.reason);\\n  });\\n}\\n```\\n\\nCancelToken has another method to check cancel. It is [CancelToken.throwIfRequested](https://github.com/axios/axios/blob/v0.21.1/lib/cancel/CancelToken.js#L36-L40).\\n```tsx\\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\\n  if (this.reason) {\\n    throw this.reason;\\n  }\\n};\\n```\\nIt check it has reason, If it has reason it decide that this is canceled token and throw it.\\n\\nThis `throwIfRequested` is showed several location in axios request. It is presumed that these measures have been taken because cancels may occur in various cases.  \\n\\n```tsx\\n// https://github.com/axios/axios/blob/v0.21.1/lib/core/dispatchRequest.js\\nfunction throwIfCancellationRequested(config) {\\n  if (config.cancelToken) {\\n    config.cancelToken.throwIfRequested();\\n  }\\n}\\n\\nmodule.exports = function dispatchRequest(config) {\\n  throwIfCancellationRequested(config);\\n  ...\\n\\n  return adapter(config).then(function onAdapterResolution(response) {\\n    throwIfCancellationRequested(config);\\n    ...\\n  }\\n}\\n```\\nTherefore, once canceled `cancelToken` is implemented to automatically reject upon request from axios.\\nIn order to normalize the axios request again after cancel, \\nthe `cancelToken` must be abandoned and a new `cancelToken` must be created to call the axios so that the axios request will not stop and make a normal call.\\n\\n## Reference\\n- [axios github](https://github.com/axios/axios/tree/v0.21.1)\\n- [axios cancellation docs](https://axios-http.com/docs/cancellation)"}]}')}}]);