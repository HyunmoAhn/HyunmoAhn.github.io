"use strict";(self.webpackChunkhyunmoahn_github_io=self.webpackChunkhyunmoahn_github_io||[]).push([[5599],{5358:(e,n,a)=>{a.d(n,{zD:()=>o,pe:()=>i,eY:()=>r,xX:()=>s,Vy:()=>c});const t="import { useEffect, useState } from 'react';\n\nexport const useAsyncData = () => {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setData([1, 2, 3]);\n    }, 2000);\n  }, []);\n\n  return data;\n};\n",l="import { useRef, useEffect, useMemo } from 'react';\n\nexport function useCallbackRef(callback) {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  return useMemo(\n    () =>\n      (...args) =>\n        callbackRef.current?.(...args),\n    [],\n  );\n}\n",o={"/App.js":"import { useEffect } from 'react';\nimport { useAsyncData } from './useAsyncData';\n\nexport default function App() {\n  const data = useAsyncData();\n  const handleCallback = () => {\n    console.log(`handle callback: ${new Date().toISOString()}`);\n  };\n\n  return (\n    <>\n      {data.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n      <ChildComponent onCallback={handleCallback} />\n    </>\n  );\n}\n\nconst ChildComponent = ({ onCallback }) => {\n  useEffect(() => {\n    onCallback();\n  }, [onCallback]);\n\n  return <>Child</>;\n};\n","/useAsyncData.js":t},i={"/App.js":"import { useEffect, useCallback } from 'react';\nimport { useAsyncData } from './useAsyncData';\n\nexport default function App() {\n  const data = useAsyncData();\n  const handleCallback = useCallback(() => {\n    console.log(`handle callback: ${new Date().toISOString()}`);\n  }, []);\n\n  return (\n    <>\n      {data.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n      <ChildComponent onCallback={handleCallback} />\n    </>\n  );\n}\n\nconst ChildComponent = ({ onCallback }) => {\n  useEffect(() => {\n    onCallback();\n  }, [onCallback]);\n\n  return <>Child</>;\n};\n","/useAsyncData.js":t},s={"/App.js":"import { useCallback, useEffect } from 'react';\nimport { useAsyncData } from './useAsyncData';\n\nexport default function App() {\n  const list = ['Hello', 'World'];\n  const data = useAsyncData();\n  const handleCallback = useCallback((index) => {\n    console.log(`handle callback: ${index}`);\n  }, []);\n\n  return (\n    <>\n      {list.map((item, index) => (\n        <ChildComponent key={index} onCallback={() => handleCallback(index)} />\n      ))}\n      {data.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n    </>\n  );\n}\n\nconst ChildComponent = ({ onCallback }) => {\n  useEffect(() => {\n    onCallback();\n  }, [onCallback]);\n\n  return <>Child</>;\n};\n","/useAsyncData.js":t},c={"/App.js":"import { useCallback, useEffect } from 'react';\nimport { useCallbackRef } from './useCallbackRef';\nimport { useAsyncData } from './useAsyncData';\n\nexport default function App() {\n  const list = ['Hello', 'World'];\n  const data = useAsyncData();\n  const handleCallback = useCallback((index) => {\n    console.log(`handle callback: ${index}`);\n  }, []);\n\n  return (\n    <>\n      {list.map((item, index) => (\n        <ChildComponent key={index} onCallback={() => handleCallback(index)} />\n      ))}\n      {data.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n    </>\n  );\n}\n\nconst ChildComponent = ({ onCallback }) => {\n  const handleCallback = useCallbackRef(onCallback);\n\n  useEffect(() => {\n    handleCallback();\n  }, [handleCallback]);\n\n  return <>Child</>;\n};\n","/useAsyncData.js":t,"/useCallbackRef.js":l},r={"/App.js":"import { useCallback, useEffect } from 'react';\nimport { useCallbackRef } from './useCallbackRef';\nimport { useAsyncData } from './useAsyncData';\n\nexport default function App() {\n  const data = useAsyncData();\n  const handleCallback = useCallback(() => {\n    if (data.length !== 0) {\n      console.log(`handle callback: ${data}`);\n    }\n  }, [data]);\n\n  return (\n    <>\n      {data.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n      <ChildComponent onCallback={handleCallback} />\n    </>\n  );\n}\n\nconst ChildComponent = ({ onCallback }) => {\n  const handleCallback = useCallbackRef(onCallback);\n\n  useEffect(() => {\n    handleCallback();\n  }, [handleCallback]);\n\n  return <>Child</>;\n};\n","/useAsyncData.js":t,"/useCallbackRef.js":l}},9288:(e,n,a)=>{a.d(n,{X:()=>E});var t=a(7294),l=a(6319),o=a(2949),i=a(362),s=a(1325),c=a(2297);const r=(0,i.ZP)(s.fC)``,d=i.ZP.div`
  display: flex;
  padding: 0 10px;
  border-bottom: 3px solid var(--ifm-color-emphasis-200);
`,p=(0,i.ZP)(s.aV)`
  flex: 1;
`,u=(0,i.ZP)(s.xz)`
  font-size: 1.1em;
  padding: 10px;

  color: var(--ifm-color-primary-darkest);
  background-color: transparent;
  border: none;

  &[data-state='active'] {
    color: var(--ifm-color-primary);
    font-weight: 500;
    border-bottom: 3px solid var(--ifm-color-primary);
  }
`,m=i.ZP.button`
  color: var(--ifm-color-emphasis-700);
  background-color: transparent;
  border: none;
`,h=(0,i.ZP)(s.VY)`
  display: none;
  height: 160px;
  overflow: scroll;

  &[data-state='active'] {
    display: block;
  }
`,k=e=>{let{defaultValue:n="result"}=e;const{refresh:a}=(0,l.xN)();return t.createElement(r,{defaultValue:n},t.createElement(d,null,t.createElement(p,null,t.createElement(u,{value:"result"},"Result"),t.createElement(u,{value:"console"},"Console")),t.createElement(m,{onClick:()=>a()},t.createElement(c.Z,{height:18,width:18}))),t.createElement(h,{value:"result",forceMount:!0},t.createElement(l.Gj,{showOpenInCodeSandbox:!1,showRefreshButton:!1})),t.createElement(h,{value:"console",forceMount:!0},t.createElement(l.Tq,{standalone:!0,resetOnPreviewRestart:!0})))};var f=a(4047),b=a(8814);const C=i.ZP.div`
  display: flex;
  gap: 10px;
  margin: 10px 14px;
`,g=i.ZP.div`
  flex: 1;
  font-size: 1.25em;

  align-self: center;

  color: var(--ifm-color-primary-dark);
`,y=i.iv`
  width: 24px;
  height: 24px;

  color: var(--ifm-color-emphasis-700);
  background-color: transparent;
  border: none;
`,x=i.ZP.button`
  ${y}
`,w=(0,i.ZP)(l.lc)`
  ${y}
`,v=e=>{let{title:n}=e;const{sandpack:a,dispatch:o}=(0,l.X3)();return t.createElement(C,null,t.createElement(g,null,n),t.createElement(x,{onClick:()=>{window.confirm("Reset All files")&&(a.resetAllFiles(),o({type:"refresh"}))}},t.createElement(f.Z,{height:16,width:16})),t.createElement(w,null,t.createElement(b.Z,{height:16,width:16})))},N=i.ZP.div`
  display: flex;
  flex-direction: column;

  border: 3px solid var(--ifm-color-emphasis-200);
  border-radius: 5px;
  height: 600px;

  margin-bottom: 30px;
`,R={"/index.js":{hidden:!0,code:'import React from "react";\nimport { createRoot } from "react-dom/client";\nimport "./styles.css";\nimport App from "./App";\nconst root = createRoot(document.getElementById("root"));\nroot.render(<App />);\n'}},E=e=>{let{files:n,title:a,strict:i=!1,defaultOutput:s}=e;const{colorMode:c}=(0,o.I)();return t.createElement(l.oT,{files:{...n,...!i&&R},theme:c,template:"react",options:{autorun:!0,autoReload:!0}},t.createElement(N,null,t.createElement(v,{title:a}),t.createElement(l._V,{style:{flex:7,overflow:"scroll"},showTabs:!0,showInlineErrors:!0,showLineNumbers:!0,wrapContent:!0}),t.createElement(k,{defaultValue:s})))}},2820:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>p});var t=a(3117),l=(a(7294),a(3905)),o=a(9288),i=a(5358);const s={slug:"avoid-re-render-by-function-props",title:"How to Avoid Re-rendering Caused by Callback Function Props",description:"This article presents a method to avoid re-rendering that can occur when injecting a callback function as props.",keywords:["react","callback function","props","re-render","ref","web"],authors:"HyunmoAhn",tags:["react","callback function","web","props","re-render","ref"]},c=void 0,r={permalink:"/en/avoid-re-render-by-function-props",source:"@site/i18n/en/docusaurus-plugin-content-blog/2023-09-10-avoid-re-render-by-function-props.mdx",title:"How to Avoid Re-rendering Caused by Callback Function Props",description:"This article presents a method to avoid re-rendering that can occur when injecting a callback function as props.",date:"2023-09-10T00:00:00.000Z",formattedDate:"September 10, 2023",tags:[{label:"react",permalink:"/en/tags/react"},{label:"callback function",permalink:"/en/tags/callback-function"},{label:"web",permalink:"/en/tags/web"},{label:"props",permalink:"/en/tags/props"},{label:"re-render",permalink:"/en/tags/re-render"},{label:"ref",permalink:"/en/tags/ref"}],readingTime:6.53,hasTruncateMarker:!0,authors:[{name:"Hyunmo Ahn",title:"Front End Engineer @ Line+",url:"https://github.com/HyunmoAhn",imageURL:"https://github.com/HyunmoAhn.png",key:"HyunmoAhn"}],frontMatter:{slug:"avoid-re-render-by-function-props",title:"How to Avoid Re-rendering Caused by Callback Function Props",description:"This article presents a method to avoid re-rendering that can occur when injecting a callback function as props.",keywords:["react","callback function","props","re-render","ref","web"],authors:"HyunmoAhn",tags:["react","callback function","web","props","re-render","ref"]},nextItem:{title:"i18n and typescript",permalink:"/en/i18n-and-typescript"}},d={authorsImageUrls:[void 0]},p=[{value:"Problem Description",id:"problem-description",level:2},{value:"Solution?",id:"solution",level:3},{value:"useCallbackRef",id:"usecallbackref",level:2},{value:"Potential Issues",id:"potential-issues",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p},m="wrapper";function h(e){let{components:n,...a}=e;return(0,l.kt)(m,(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"In React, when passing a function as component props, one needs to be careful with managing references\nto avoid unnecessary re-renders.\nAlthough most case we use ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallback")," to prevent unnecessary re-renders, I found an alternative solution sharing."),(0,l.kt)("p",null,"The code that inspired this article is ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/radix-ui/primitives"},"radix-ui/primitives"),"'s ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/radix-ui/primitives/blob/main/packages/react/use-callback-ref/src/useCallbackRef.tsx"},"useCallbackRef"),".\nThis article will discuss the use cases and logic of ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef"),"."),(0,l.kt)("p",null,"Below is the ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef")," code we are going to discuss.\nCan you guess in what situations it might be used?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"// useCallbackRef.js\nimport { useRef, useEffect, useMemo } from 'react';\n\nexport function useCallbackRef(callback) {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  return useMemo(() => ((...args) => callbackRef.current?.(...args)), []);\n}\n")),(0,l.kt)("h2",{id:"problem-description"},"Problem Description"),(0,l.kt)("p",null,"First, let's introduce a case where a problem occurs due to function props.\nThis is a simple example where the reference of a function changes due to a state change,\naffecting the children as well."),(0,l.kt)(o.X,{title:"Basic Problem",files:i.zD,defaultOutput:"console",mdxType:"Playground"}),(0,l.kt)("p",null,"The problem in the above code is that ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," is called twice."),(0,l.kt)("p",null,"The purpose of the example code is to update the data after 2 seconds using ",(0,l.kt)("inlineCode",{parentName:"p"},"useAsyncData"),",\nand separately, to pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," function to the ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent")," to call it once at the mount."),(0,l.kt)("p",null,"The detailed flow is as follows."),(0,l.kt)("mermaid",{value:'flowchart LR\n    First["App \\ndata: []\\n handleCallback"] -- Initial Render --\x3e FirstChildren["ChildComponent\\n onCallback: handleCallback"] --\x3e Emit["Emit first"]'}),(0,l.kt)("p",null,"In the first render, the data is empty, and ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," is passed to the child and called once."),(0,l.kt)("mermaid",{value:'flowchart LR\n    Second["App \\ndata: [1, 2, 3]\\n handleCallback`"] -- After update data --\x3e SecondChildren["ChildComponent\\n onCallback: handleCallback`"] --\x3e Emit["Emit Second"]'}),(0,l.kt)("p",null,"After the data is updated, App.js creates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," and passes it to ChildComponents,\nSo ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," is called for the second time."),(0,l.kt)("h3",{id:"solution"},"Solution?"),(0,l.kt)("p",null,"Of course, in the above example, if you use ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallback")," to memoize ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," regardless of the data update,\nthe problem can be solved."),(0,l.kt)(o.X,{title:"Basic Problem with useCallback",files:i.pe,defaultOutput:"console",mdxType:"Playground"}),(0,l.kt)("p",null,"We could conclude the article with the lesson that when passing function props,\nyou need to be mindful of memoization. But what about the next example?"),(0,l.kt)(o.X,{title:"List Problem",files:i.xX,defaultOutput:"console",mdxType:"Playground"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"const handleCallback = useCallback((index) => {\n  console.log(`handle callback: ${index}`);\n}, []);\n\n...\n{list.map((item, index) => (\n  // highlight-next-line\n  <ChildComponent key={index} onCallback={() => handleCallback(index)} />\n))}\n")),(0,l.kt)("p",null,"In this example, unlike the previous one, the callback functionis injected as props of a component that iterates over a list,\nand it receives the index data, which can only be known when iterating over items, as params."),(0,l.kt)("p",null,"Under these case, even if ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," is memoized with useCallback, it is unintentionally called multiple times due to the anonymous function created during rendering."),(0,l.kt)("p",null,"There is also a solution for this. If you pass the index as props and call ",(0,l.kt)("inlineCode",{parentName:"p"},"onCallback")," and index inside ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent"),"\ninstead of using an anonymous function, this problem is solved. However, in actual situations, ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent")," may be a component\nthat can't be controlled (like external library) or a common component with a wide range of influence, making problem solving more complex."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"There is also a mehtod that modifies the dependency of useEffect in ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponnet"),"\nwithout using the various methods suggested above."),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"const ChildComponent = ({ onCallback }) => {\n  useEffect(() => {\n    onCallback();\n  // highlight-next-line\n  }, []);\n\n  return <>Child</>;\n};\n")),(0,l.kt)("p",{parentName:"admonition"},"In this case, duplicate calls can be resolved and it may be fine to use this method by some case.\nHowever, it violates the React hook related lint rule ",(0,l.kt)("a",{parentName:"p",href:"https://legacy.reactjs.org/docs/hooks-rules.html#eslint-plugin"},"react-hooks/exhaustive-deps")," and\ncan make debugging difficult, so it is not considered in this article."),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre"},"ESLint: React Hook useEffect has a missing dependency:\n'onCallback'. Either include it or remove the dependency array.\nIf 'onCallback' changes too often, find the parent component that defines it and wrap that definition in useCallback.\n(react-hooks/exhaustive-deps)\n"))),(0,l.kt)("h2",{id:"usecallbackref"},"useCallbackRef"),(0,l.kt)("p",null,"Let's use ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef"),". I applied ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef")," directly to this list example we just saw."),(0,l.kt)(o.X,{title:"Use Callback Ref",files:i.Vy,defaultOutput:"console",mdxType:"Playground"}),(0,l.kt)("p",null,"Based on the results, unnecessary ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," calls do not seem to be found. Did I modify the example code a lot?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"showLineNumbers",showLineNumbers:!0},"// App.js\nconst ChildComponent = ({ onCallback }) => {\n  // highlight-start\n  const handleCallback = useCallbackRef(onCallback);\n  // highlight-end\n\n  useEffect(() => {\n  // highlight-start\n    handleCallback();\n  }, [handleCallback]);\n  // highlight-end\n\n  return <>Child</>;\n};\n")),(0,l.kt)("p",null,"There are no changes in App.js, and there are changes in the internal logic of ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent")," using ",(0,l.kt)("inlineCode",{parentName:"p"},"onCallback"),".\n",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent")," uses ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," which wraps the ",(0,l.kt)("inlineCode",{parentName:"p"},"onCallback")," received as props using ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef"),",\nand also uses ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," as  a dependency of useEffect."),(0,l.kt)("p",null,"So what's inside ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef"),"?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"showLineNumbers",showLineNumbers:!0},"// useCallbackRef.js\nimport { useRef, useEffect, useMemo } from 'react';\n\nexport function useCallbackRef(callback) {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  return useMemo(() =>\n    (...args) => callbackRef.current?.(...args),\n  []);\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef")," provides two functions."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"It continuously updates the ",(0,l.kt)("inlineCode",{parentName:"li"},"ref")," by receiving the callback function as params.")),(0,l.kt)("p",null,"If you look closely, ",(0,l.kt)("inlineCode",{parentName:"p"},"callbackRef")," is updated every time the callback is updated without dependency at ",(0,l.kt)("inlineCode",{parentName:"p"},"L7-L9"),"."),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"It returns function that calls the callback stored in callbackRef.")),(0,l.kt)("p",null,"Here, it uses ",(0,l.kt)("inlineCode",{parentName:"p"},"useMemo")," to prevent the return value from being updated and calls the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"callbackRef"),"\nwhen the return value is called, so it call always call the latest callback."),(0,l.kt)("p",null,"The detailed flow is as follows."),(0,l.kt)("mermaid",{value:'flowchart LR\n    First["App \\ndata: []\\n handleCallback"] -- Initial Render --\x3e FirstChildren["ChildComponent\\n callbackRef: handleCallback\\n MemoCallback"] --\x3e Emit["Emit first"]'}),(0,l.kt)("p",null,"The initial flow is similar to the previous one.\nApp passes ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponent")," stores ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"callbackRef"),"\nand uses ",(0,l.kt)("inlineCode",{parentName:"p"},"MemoCallback"),". The function called at ",(0,l.kt)("inlineCode",{parentName:"p"},"Emit First")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"MemoCallback"),",\nand since ",(0,l.kt)("inlineCode",{parentName:"p"},"MemoCallback")," points to ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback"),", we can see that the function actually called is ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback"),"."),(0,l.kt)("mermaid",{value:'flowchart LR\n    Second["App \\ndata: [1, 2, 3]\\n handleCallback`"] -- After update data --\x3e SecondChildren["ChildComponent\\n callbackRef: handleCallback`\\n MemoCallback"] --x Emit["Emit Second"]'}),(0,l.kt)("p",null,"The second flow is changed. When the data is updated and handleCallback is newly created as ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback` ")," and passes to ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildComponnet"),",\n",(0,l.kt)("inlineCode",{parentName:"p"},"callbackRef")," updates it, but ",(0,l.kt)("inlineCode",{parentName:"p"},"MemoCallback")," used inside the component does not change its reference, so the second call does not occur."),(0,l.kt)("p",null,"This method can be useful when designing components, especially because it allows internal optimization without imposing a rule\nthat memoization must be done externally."),(0,l.kt)("h2",{id:"potential-issues"},"Potential Issues"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef")," cannot be the solution to everything. In the examples above, if ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," needs to be called the second time, not the first time,\nthe second call does not occur, so it may not work as intended."),(0,l.kt)("p",null,"The following example is code intended to call ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," with data information."),(0,l.kt)(o.X,{title:"Edge Case",files:i.eY,defaultOutput:"console",mdxType:"Playground"}),(0,l.kt)("p",null,"In the example, it seems that ",(0,l.kt)("inlineCode",{parentName:"p"},"handleCallback")," is not being called properly due to ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"// handleCallback\nconst data = useAsyncData();\n\nconst handleCallback = useCallback(() => {\n  // highlight-start\n  if (data.length !== 0) {\n    console.log(`handle callback: ${data}`);\n  }\n  // highlight-end\n}, [data]);\n")),(0,l.kt)("p",null,"Since it operates on the premise that ",(0,l.kt)("inlineCode",{parentName:"p"},"data")," exists (",(0,l.kt)("inlineCode",{parentName:"p"},"data.length !== 0"),"),\nit can be seen that the correct purpose is rater to induce duplicate calls."),(0,l.kt)("h2",{id:"conclusion"},"Conclusion"),(0,l.kt)("p",null,"In React, we introduced the operation of a custom hook called ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef")," as a solution other than orthodox\nmethods like ",(0,l.kt)("inlineCode",{parentName:"p"},"useCallback")," for issues that can occur due to re-rendering when passing a function as props."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"useCallbackRef")," always preserves the most recent props function in the ",(0,l.kt)("inlineCode",{parentName:"p"},"ref")," by storing the function received as props in the ",(0,l.kt)("inlineCode",{parentName:"p"},"ref")," each time.\nHowever, since the return value is exposed wrapped in useMemo, re-rendering due to props changes does not occur."),(0,l.kt)("p",null,"Through this, it is possible to prevent calls due to unintentional re-rendering while obtaining the most recent callback function\nat the time of callback function call."),(0,l.kt)("p",null,"However, if there are cases where the call is delayed or called multiple times depending on the dependency,\nthis logic could rather be a poison, so you should make a good judgment according to the case."))}h.isMDXComponent=!0}}]);